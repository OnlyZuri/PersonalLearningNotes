# Leetcode-树

## Day 1

### 94. Binary Tree Inorder Traversal

​		**Morris算法：**按照中序遍历的思想，当该节点有左节点时，需要在左节点最右的叶子节点访问完了之后才会访问该节点。因此，若节点有左节点，则将该节点接到左节点的最右叶子节点的右孩子上。

​		**迭代算法：**迭代中序，需要保存当前节点的前驱节点，因此使用栈作为存放前驱节点的数据结构。当该节点有左节点时，节点入库，同时判断左节点情况。循环直到节点没有左节点即弹出，访问其右节点再从栈中弹出最顶节点。依次循环。

​		**Morris和迭代算法注意事项：**迭代算法不需要清除子树，Morris也能做到不修改树结构。		



### 95. Unique Binary Search Trees II

​		**回溯法：**由回溯法产生数列的所有排列可能，然后通过数列来建立对应的BST。缺点是即使数列不一致，也会有BST结构一致的情况，如213和231，此时就意味着回溯法有重复现象，需要判重。

​		**递归：**考虑到BST的不同在于选定根节点之后，左右子树的可能排列。而左右子树的可能排列又相当于它们的根节点确定后，各自的左右子树的可能排列。即存在重复问题，使用递归解决。



### 96. Unique Binary Search Trees

​		**递归+备忘录：**同95题一样，考虑递归解决，只不过换成了统计左右子树的可能数量。由于存在重复计算，因此使用备忘录。

​		**动态规划：**观察规律，具体看题解。

​		**卡特兰数：**由上面的规律发现符合卡特兰数，根据卡特兰数特征，按照公式计算。



## Day 2

### 98. Validate Binary Search Tree

​		**递归：**关于树的递归算法，不一定要左右两端同时开始，尤其是BST，可以从左边开始。

​		**中序：**BST的中序就是一个从小到大的数组，按照此特性可以解决很多BST问题。



### 99. Recover Binary Search Tree

​		**中序：**依旧跟中序相关，三种算法分别是递归中序、迭代中序、Morris中序。



## Day 3

### 100. Same Tree

​		**递归DFS：**递归方式，以深度优先搜索来判定某个子树是否相等。

​		**队列BFS：**队列实现广度优先搜索，逐层判定每个节点是否相等。



### 101. Symmetric Tree

​		**递归：**判断左子树和右子树是否对称，根据递归顺序递进，变成判断左子树的左子树与右子树的右子树是否对称。

​		**队列BFS：**通过队列来存放每一层的节点，但是要注意右子树的节点要从右边开始放入队列。



### 102. Binary Tree Level Order Traversal

​		**队列BFS：**通过BFS实现层次遍历



### 103. Binary Tree Zigzag Level Order Traversal

​		**双端队列：**奇数层从队首逐渐取出元素，将左节点、右节点从尾部加入队列。偶数层从队尾取出元素，将右节点、左节点从首部加入队列。

​		**双栈：**奇数层从栈A读取元素，将左节点、右节点放入栈B。偶数层从栈B读取元素， 将右节点、左节点放入栈A。



### 104. Maximum Depth of Binary Tree

​		**递归DFS：**深度优先搜索，递归读取左右子树高度。



### 105. Construct Binary Tree from Preorder and Inorder Traversal

​		**递归：**递归实现，每次从先序中找出根，然后在中序找出左右子树的范围，然后按照这个逻辑，递归生成左右子树。



## Day 4

### 106. Construct Binary Tree from Inorder and Postorder Traversal

​		**递归：**递归实现，思路与105题基本一致。区别在于中序是左根右，后序是左右根。应该首先确定根的位置，因此以后序的数组为主导，确定最后一位为根，然后在中序里确定根的位置，将中序分成左、右部分，最后确定后序的左右部分。然后递归解决。



### 107. Binary Tree Level Order Traversal II

​		**队列BFS：**层次遍历BFS，但需要注意的是结果从头部插入。注：Queue只有add、offer、poll、peek等方法，List只有add等方法，LinkedList的对象，但是声明为Queue和List时不能直接使用addLast、addFirst等方法。



### 108. Convert Sorted Array to Binary Search Tree

​		**递归：**由于是单调递增的数组，取中间元素作为根，则左边的作为左子树，右边的作为右子树，符合BST特征。接下来左右子树的创建与初始方案一致，递归解决。中间元素选择有2种：靠左（start + end） /  2，靠右（start + end + 1）/ 2



### 109. Convert Sorted List to Binary Search Tree

​		**递归：**递归实现，由于链表不确定长度，因此可以先遍历链表找它的长度。由于链表没办法随机访问，因此建立结点时只能按照链表顺序来。由于问题可以分解为确定中点，然后找左右子树，可以来递归解决。但是**重点在于定义全局变量来表示当前访问到链表的哪个节点**。



### 110. Balanced Binary Tree

​		**递归：**判定是否平衡二叉树，就是看左右子树的高度是否差值绝对值≤1。有两种方式，如果自顶向下，先判定当前节点的左右子树高度是否满足条件的话，到了左右子树的平衡判定时，树高有些地方重复算了一次。而如果采用自底向上，则每个节点只会被访问一次，同时将最大高度往上传递。



## Day 5

### 111. Minimum Depth of Binary Tree

​		**递归DFS：**需要判定是否是叶子结点，如果结点某个子树为空，但是另一个子树不为空时，需要把为空子树的深度设置为Integer.MAX_VALUE，避免被当成0来判断，影响最终结果。

​		**队列BFS：**广度优先搜索，查看当前层次是否有某个结点左右子树均为空，则此时必为叶子结点，直接输出当前层高就行。



### 112. Path Sum

​		**递归DFS/队列BFS：**判断当前结点的值是否为targetSum，且该节点是否叶子节点。否则将该节点的值加给它的子节点。



### 113. Path Sum II

​		**递归DFS：**递归传递当前路径和路径总和，避免重复计算

​		**队列BFS：**需要辅助空间，存放当前路径和该路径和。



### 114. Flatten Binary Tree to Linked List

​		**递归：**有较多种方法实现，但是递归可实现O(1)空间复杂度解决问题。需要注意的是前驱节点的替换和右节点的保留。



### 116. Populating Next Right Pointers in Each Node

​		**队列BFS：**由于题目限定是满二叉树，所以层次遍历修改next即可。

​		**指针：**由于使用next连接右边的节点，因此可以利用next进行层次遍历。每次使用first为当前层的最左结点，每次循环将该层的左右子树的next建立好关系，左结点的next为右结点，右节点的next为当前结点的next的左节点。



## Day 6

### 117. Populating Next Right Pointers in Each Node II

​		**队列BFS：**做层次遍历修改next。

​		**指针：**与116做法一致，只是需要循环找第一个有左或右子树的结点，以及下一个有左或右子树的结点。



### 124. Binary Tree Maximum Path Sum

​		**递归：**自底向上的递归，避免多次重复计算。题目不难，但是要注意题目要求一个节点最多使用一次，因此左->根->右这样的连接只能是最顶层，不能再传给上一层使用，因为不存在一种连线能从左到根到右，然后不绕过根还能往上走。



### 129. Sum Root to Leaf Numbers

​		**递归DFS/队列BFS：**把父节点的值*10，加到子节点上。在叶子节点进行总和计算。



### 144. Binary Tree Preorder Traversal

​		**递归：**简单的先序框架

​		**迭代：**用栈来保存未访问节点，先让入右节点，然后让当前访问节点变成左节点。

​		**Morris：**将当前节点的右节点放到左节点的最右节点的右子树上。



### 145. Binary Tree Postorder Traversal

​		**递归：**简单的后序框架

​		**迭代：**左右根的方向可以改成根右左，从前面插入元素

​		**Morris：**同上，用根右左逆序插入元素