# 微服务架构设计模式

## （一）逃离单体地狱

### 1）单体架构的好处（应用程序较小时）

* **应用开发简单**，IDE只需要构建一个单独的应用程序
* **易于对应用程序进行大规模的更改**，如更改数据库模式
* **测试相对简单直观**
* **部署简单明了**
* **横向扩展简单**，可以运行多个实例，只需要做好负载均衡



### 2）什么是单体地狱

* **过度的复杂性会吓退开发者**，系统的庞大和复杂会加大开发者的理解难度，导致问题修复和新功能实现困难。
* **开发速度缓慢**，IDE工具打开项目缓慢，构建运行测试周期耗时间长。
* **从代码提交到实际部署的周期很长，而且很容易出问题**。众多开发者向同一个代码库提交修改，合并过程痛苦，且测试和代码稳定周期长；运行测试需要很长时间。
* **难以扩展**。不同模块对资源的需求是有可能互相冲突的，导致横向扩展选择服务器时必须满足所有模块的需要，如高性能CPU，大内存等。
* **交付可靠的单体应用是一项挑战（缺乏可靠性）**。系统庞大意味着无法进行全面和彻底的测试，且缺乏故障隔离，若某个模块出现故障如内存泄漏，将导致整个应用程序崩溃
* **需要长期依赖某个可能过时的技术栈**，单体架构使得采用新的框架和编程语言变得极其困难。



### 3）扩展立方体

<img src = 'https://s3.bmp.ovh/imgs/2022/04/10/5cd35e64c1bc09cf.png' width=600 align="left"/>



### 4）微服务作为模块化的一种形式

* **微服务架构使用服务作为模块化的单元，服务的API为自身构筑了一个不可逾越的边界，无法越过API去访问服务内部的类。**
* **微服务的每一个服务之间是松耦合的，每个服务都拥有自己的私有数据库（非绝对）。**



### 5）微服务与SOA的区别

* **SOA（Service Oriented Architecture）面向服务架构**。
* **SOA使用重量级技术，如使用ESB（Enterprise Service Bus）进行服务间的通信。**而微服务架构倾向于使用轻量级技术。
* **SOA通常使用全局数据库并且共享，微服务架构都拥有自己的数据库**
* **SOA服务的规模相对较大，集成大型、复杂的单体应用程序。**



### 6）微服务架构的好处

* **使大型的复杂应用程序可以持续交付和持续部署**，并通过以下三种方式实现持续交付和持续部署：
  * **拥有持续交付和持续部署所需要的可测试性**，自动化测试是持续交付和持续部署的一个重要环节，每个服务都相对较小，编写和执行自动化测试相对容易。
  * **拥有持续交付和持续部署所需要的可部署性**，每个服务都可以独立于其他服务进行部署，修改服务不需要协调
  * **使开发团队自主且松耦合**，每个团队可独立于其他团队开发、部署和扩展服务。

* **每个服务都相对较小且易于维护**
* **服务可以独立扩展**
* **更好的容错性**，实现更好的故障隔离
* **更容易实验和采纳新的技术**



### 7）微服务架构的弊端

* **服务的拆分和定义是一项挑战**，服务的拆分没有具体且良好的定义算法，拆分不善将导致构建出**分布式的单体应用**，集齐单体架构和微服务架构的弊端。
* **分布式系统带来的复杂性**，如服务之间必须使用进程间通信机制、实现跨服务的事务和查询变得困难、IDE不具备分布式应用所需要的特定功能支持、运维复杂性等。
* **当部署跨越多个服务的功能时需要协同更多开发团队**，需要制定发布计划，将服务按照依赖关系进行排序。
* **开发者需思考在应用的什么阶段使用微服务架构**



### 8）模式语言

* **模式结构三个重要部分**：

  * **需求：必须解决的问题**。需求有时候是冲突的，必须将需求按照优先级进行排序**。**
  * **结果上下文：采用模式后可能带来的结果**。包含三个部分：**好处**（模式的好处与解决的需求）、**弊端**（模式的弊端和没有解决的需求）、**问题**（使用模式引入的新问题）。
  * **相关模式：描述模式与其他模式的关系。**包括**前导模式**（催生这个模式的需求的模式）、**后导模式**（用于解决当前模式引入的新问题的模式）、**替代模式**、**泛化模式**（针对问题的一般性解决方案）、**特化模式**（针对问题的具体解决方案）。

  

<img src = 'https://i.bmp.ovh/imgs/2022/04/10/665e6aaae3eb803f.png' width="600"/>

* **微服务架构的模式语言分为三组：**
  * **基础设施相关模式组：解决开发环节和基础设施有关的问题**
  * **应用基础设施相关模式组：解决应用层面的基础设施有关问题**
  * **应用相关模式组：解决开发人员面对的具体技术和架构问题**
  * 进一步分组的话包括**服务拆分、通信、实现事务管理的数据一致性、在微服务架构中查询数据、服务部署、可观测性、实现服务自动化测试、解决基础设施和边界问题、安全**等相关模式。



## （二）服务的拆分策略

### 1）软件架构

* **计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性**。按照这个概念，软件架构分为**元素以及元素之间的关系**。

* **软件架构4+1视图模式**：

  * **逻辑视图：开发人员创建的软件元素**。面向对象的语言中，元素是**类和包**，关系是**继承、关联和依赖。**

  * **实现视图：构建编译系统的输出。打包代码中的模块和组件构成，**组件是由一个或多个模块组成的可执行或部署单元。**模块是JAR文件，组件通常是WAR文件或可执行JAR文件**。关系是**模块间的依赖关系**以及**组件和模块间的组合关系**。

  * **进程视图：运行时的组件**。元素是**进程**，关系是**进程间通信**。

  * **部署视图：进程如何映射到机器。元素由计算机和进程组成，机器间的关系是网络**。

  * **场景：负责把视图串联在一起，每个场景负责描述在一个视图中的多个架构元素如何协作以完成一个请求**。

    <img src = 'https://i.bmp.ovh/imgs/2022/04/10/a9a39cf27085f29d.png' width=400 align="left"/>



* **架构的重要性**：架构的重要性在于它满足了应用程序的**非功能性需求**，包括**可维护性、可测试性、可扩张性和可部署性**。



### 2）架构风格

* **特定的架构风格提供了有限的元素（组件）和关系（连接器），可用于定义应用程序架构的视图。**
* **分层式架构风格**：将软件元素按“层”的方式组织，每个层由明确定义的职责，且只能依赖于紧邻其下方的层。可应用于四种视图中任何一个。**典型的三层架构应用于逻辑视图**。
  * 包含**表现层**（包含实现用户界面或外部API的代码）、**业务逻辑层**（包含业务逻辑）、**数据持久化层**（实现与数据库交互的逻辑）。
  * 弊端：**单个表现层**，无法展示应用程序不仅由单个系统调用的事实；**单一数据持久层**，无法展示应用程序可能与多个数据库进行交互的事实；**将业务逻辑层定义为依赖于数据持久层**，影响在没有数据库的情况下测试业务逻辑；**业务逻辑通常定义数据访问方法的接口或接口库，而数据化持久层则定义了存储库接口的DAO类，依赖关系与分层架构描述的相反。**

* **六边形架构风格：以业务逻辑为中心，配备多个出入站适配器。**

  * 业务逻辑不依赖适配器，适配器依赖业务逻辑。

  * 业务逻辑具有多个**端口，定义了与外部交互的操作。**分为**入站端口**（业务逻辑公开的API，使外部应用程序可以调用它，如**服务接口**）和**出站端口**（业务逻辑调用外部系统的方式，如**存储库接口**）。Java中端口通常是Java接口。

  * 业务逻辑周围有两种适配器：**入站适配器**（通过调用入站端口来处理外部的请求，如MVC Controller、消息代理客户端）、**出站适配器**（实现出站端口，并通过调用外部应用程序或服务来处理来自业务逻辑的请求，如DAO类）。

    <img src = 'https://i.bmp.ovh/imgs/2022/04/10/bfc4f665087f7f1a.png' align="left" width=500/>





### 3）微服务架构是一种架构风格

* **单体架构的实现视图是单个组件，而微服务架构的实现视图是多个组件（一组可执行文件或WAR文件）**。微服务的组件是**服务**，连接器是协作的**通信协议**。每个服务可以有自己的逻辑视图，通常是六边形架构。

* **什么是服务**：

  * 服务是**单一的、可独立部署**的软件组件。

  * 服务**具有API**，封装了内部实现。有2种类型操作，命令与查询。**API由命令、查询和事件组成**。开发人员无法绕过API直接访问服务内部方法或数据。因此，微服务架构强制实现了应用程序的模块化。

  * **每项服务都有自己的架构**，可能有独特技术栈。典型的服务都有六边形架构，API由与服务的业务逻辑交互的适配器实现，操作适配器调用业务逻辑，事件适配器对外发布业务逻辑产生的事件。

    <img src="https://4ever.web3img.com/2022/04/10/image.png" width=500 align="left"/>

* **什么是松耦合**：
  * 微服务架构的最核心特性就是**服务之间的松耦合性**。
  * **服务之间的交互采用API完成，封装服务内部细节**，允许服务在不影响客户端情况下进行修改。
  * 松耦合服务是改善开发效率、提升可维护性和可测试性的关键。
* **共享类库的角色**：实现不太可能改变的功能，创建一个供所有服务使用的共享库。



### 4）为应用程序定义微服务架构

* **通用三步式流程：定义系统操作—— >定义服务——>定义服务API和协作方式**

* **定义系统操作：第一步创建由关键类组成的抽象领域模型，第二步确定系统操作，并根据领域模型描述每个系统操作的行为。**抽象领域模型即关键类，系统操作包含命令型和查询型，命令规范定义了命令对应的参数、返回值、前置条件与后置条件。

  <img src="https://4ever.web3img.com/2022/04/10/imagec014f6a6ad4b97bf.png" width=400 align="left">

  <img src="https://4ever.web3img.com/2022/04/10/imagea5be1fef9a971243.png" width=400 align="left" >

* **定义服务策略一，根据业务能力进行服务拆分**：组织的业务能力通常是指组织的业务是做什么。

  * **识别业务能力**：通过分析识别业务能力，包括顶级能力和分解的子能力。

  * **从业务能力到服务**：确定业务能力后，为每个能力或相关能力组定义服务。决定将哪个级别的能力层次映射到服务是非常主观的判断。

    <img src="https://4ever.web3img.com/2022/04/10/image63df27be70590707.png" width=350 align="left">

  * 围绕能力组织服务的一个关键好处在于稳定，但随着的推移，有可能后续要根据需要将一些服务组合在一起。

* **定义服务策略二，根据子域进行服务拆分**：

  * 传统架构模型建立一个单独的模型，存在适用于全局的业务实体，如客户和订单。让所有团队进行统一的理解很困难，不同团队针对同一概念也可能使用不同术语。

  * **领域驱动为每一个子域定义单独的领域模型**，子域是领域的一部分，领域是DDD中用来描述应用程序问题域的一个术语。**识别子域的方式与识别业务能力一样。**

  * **领域模型的边界称为限界上下文，包括实现这个模型的代码集合，微服务架构中，每个限界上下文对应一个或一组服务。**

  * 通过使用领域驱动设计的方式定义子域，并把子域对应为每一个服务，即可完成微服务架构的设计工作。

    <img src="https://4ever.web3img.com/2022/04/10/imageb7ad7d28b987b1df.png" width=350 align="left">

* **服务拆分的指导原则**：
  * **单一职责原则**：设计小的、内聚且仅含有单一职责的服务，缩小服务的大小并提升稳定性。
  * **闭包原则**：根据同样原因进行变化的服务放在一个组件内，可以控制服务的数量，当需求改变时，变更和部署也会更加容易。

* **拆分单体应用为服务的难点**：
  * **网络延迟**：对服务的特定分解会导致两个服务之间的大量往返调用，解决方式包括实施批处理API，在一次往返中获取多个对象；或者把多个相关服务组合在一起，用函数调用替代进程通信。
  * **同步进程间通信导致可用性降低**：类似REST的通信协议会降低服务的可用性，可考虑使用异步消息的方式解决。
  * **在服务间维持数据一致性**：某些系统操作需要更新多个服务中的数据，如何保持数据一致性。解决方案包括使用基于两段式提交的分布式事务管理机制或者Saga使用消息协作的本地事务。
  * **获取一致的数据视图**：很难跨多个数据库获得真正一致的数据视图。
  * **上帝类阻碍拆分**：上帝类是整个应用程序中使用到的全局类，如Order类。解决方案包括将Order打包到库中并创建一个中央Order数据库，其他服务使用此库并访问该数据库，但这种方式会造成紧耦合，上帝类的修改会导致其他服务跟着修改；另一站方式是把Order封装成服务，其他服务通过服务调用来检索和更新订单，但这种方式会将Order服务变成纯数据服务，成为几乎不包括业务逻辑的贫血领域模型。最好的方案是使用DDD，将每个服务视为单独子域，每个服务有自己的领域模型和对应的Order类版本。
  
* **定义服务API和协作方式**：
  * **把系统操作分配给服务**：第一步是确定哪个服务是请求的初始入口。
  * **确定支持服务协作所需要的API**：除了可以由单个服务处理的系统操作，其他系统操作需要跨越多个服务，因此为了完整定义服务API，需要分析每个系统操作并确定所需要的协作。



## （三）微服务架构中的进程间通信

### 1）交互方式

* **一对一或一对多**：每个客户端请求由一个或多个服务实例来处理。

* **同步或异步模式**：客户端请求是否需要服务段实时响应，客户端请求是否阻塞进程。

  <img src="https://4ever.web3img.com/2022/04/11/image.png" width=450 align="left">

* **概念解释**：单向通知（**客户端发送请求，不期望服务端做出响应**）、发布 / 异步响应（**客户端发送请求消息，等待被感兴趣的服务发回响应**）。



### 2）在微服务架构中定义API

* 服务的API由**客户端可以调用的方法**和**服务发布的事件组成**， 方法具备名称、参数和返回类型，事件具有一个类型和一组字段。
* 为避免前后端，组件和API之间的冲突，采用API优先的设计方法值得考虑。



### 3）API的演化

* API不可避免地会随着应用功能地增减而发送变化，微服务架构中无法强求客户端和服务端地API版本保持一致，且基于高可用要求，一般采用滚动升级的方式更新服务，因此服务的旧版和新版存在共存的情况。
* **语义化版本控制**：一组规则，用于指定如何使用版本号，并且以正确的方式递增版本号，对API版本控制提供指导。**语义化版本控制规范要求版本号分为三部分**：**MAJOR**（对API进行不兼容的更改）、**MINOR**（对API进行向后兼容的增强）、**PATCH**（进行向后兼容的错误修复）。在API中使用版本号，如**REST API可以在URL路径上作为元素**或**在消息机制发布的消息中包含版本号。**

* **进行次要且向后兼容的改变**：若只进行此类型更改，则老版本客户端可以直接使用，前提是客户端和服务都遵守健壮性原则，**服务为缺少的请求属性提供默认值，客户端忽略额外的响应属性。为了避免问题，客户端和服务必须使用支持健壮性原则的请求和相应格式，如JSON、XML**。

* **进行主要且不兼容的改变**：由于无法强制客户端立即升级，因此**服务必须在一段时间内同时支持新旧版本的API**。若使用HTTP进程间通信，如**REST可以在URL中嵌入主要版本号**，如/v1/...和/v2/...作为区别；或者**使用HTTP的内容协商机制，并在MIME类型中包含版本号**。
* 为了支持多个版本的API，**实现API的服务适配器将包含在新旧版本进行转换的逻辑**。



### 4）消息格式

* **基于文本的消息格式**：如JSON和XML。文本型消息格式的**好处在于可读性高，自描述，具有很好的向后兼容性**。**弊端在于消息往往过度冗长**，尤其是XML，**消息的每次传递都反复包含除了值以外的属性名称，造成而外开销，且解析文本会引入额外开销**，尤其是在消息较长时。因此，**若对效率和性能敏感，应考虑基于二进制格式的消息。**
* **二进制消息格式**：如**Protocol Buffers和Avro**。这两种格式都提供了强类型定义的接口描述文件IDL，用于定义消息的格式。**编译器会自动根据这些格式生成序列化和反序列化的代码，因此必须采用API优先的方法来设计服务**。**Protocol Buffers使用带标记的字段tagged fields，而Avro的消费者在解析消息前必须指导它的格式。因此若实现API的演化，优先选择Protocol Buffers。**



### 5）基于同步远程过程调用模式的通信

* 代理接口通常封装底层通信协议，常见的有**REST和gRPC**。

<img src="https://4ever.web3img.com/2022/04/11/image1c3396a6d31f78aa.png" width=400 align="left">



### 6）同步通信协议之REST

* REST的**资源通常表示单个业务对象**，如客户、产品或业务对象集合。REST**使用HTTP动词来操作资源，使用URL引用这些资源。如GET请求返回资源的表示形式，该资源通常采用XML文档或JSON、二进制格式等；POST请求创建新资源，PUT请求更新资源**。
* **REST成熟度模型**：
  * Level 0：客户端只向服务端发起POST请求，进行服务调用。
  * Level 1：引入了资源的概念，要执行对资源的操作，客户端需要发出指定要执行的操作和包含任何参数的POST请求。
  * Level 2：使用HTTP动词来执行操作，请求查询参数和主体指定操作的参数，这让服务可以借助Web基础设施服务，如通过CDN来缓存GET请求。
  * Level 3：基于HATEOAS原则设计，基本思想是在由GET请求返回的资源信息中包含连接，表示能过执行该资源允许的操作。
* **定义REST API的难题**：
  * **在一个请求中获取多个资源**：解决方案是**API允许客户端在获取资源时检索相关资源**，如GET/orders/order-id-1345?expand=consumer检索Order和相关Consumer，但实现它很耗时，导致了**替代技术如GraphQL和Falcor的出现，实现了高效的数据获取**。
  * **把操作映射为HTTP动词**：**REST应该使用PUT进行更新，但可能由多种更新方式，且更新可能不是幂等的，但PUT却对此有要求**。解决方案是**定义用于更新资源的特定方面的子资源**，如取消订单POST/orders/{orderId}/cancel，修改订单POST/orders/{orderId}/revise；另一方案是**将动词指定为URL的查询参数**。但这两种都不是很符合RESTful要求，催生了替代品**gPRC**。
* **REST的好处与弊端**：
  * 可以使用Postman或curl测试HTTP API、直接支持请求/响应方式的通信、HTTP对防火墙友好、不需要中间代理，减化系统架构。
  * 只支持请求/响应方式的通信、由于客户端和服务端直接通信没有代理缓存信息，因此必须同时在线，导致可用性降低、客户端必须指导服务实例位置，引入服务发现、包含上述2个难题



### 7）同步通信协议之gRPC

* 由于HTTP仅提供有限数量的动词，因此设计支持多个更新操作的REST API存在困难。为避免此问题使用**gRPC，这是一个编写跨语言客户端和服务端的框架，基于二进制消息协议。客户端和服务端使用HTTP/2以Protocol Buffer格式交换二进制消息，Protocol Buffer是一种标记格式，每个字段都有编号，消息接收方可以跳过无法识别的字段，具有向后兼容能力**。
* gRPC除了支持简单的请求/响应RPC之外，**还支持流式RPC，服务端和客户端可用消息流通信。**

* **gRPC的好处与弊端**：
  * 设计具有复杂更新操作的API简单；具有高效、紧凑的进程间通信机制，尤其在交换大量消息时；支持RPI过程和消息传递过程中使用双向流式消息方式；实现了客户端和用各种语言编写的服务端之间的互操作性。
  * 与使用REST/JSON的API机制相比，JS使用gRPC的API需要做更多工作；旧式防火墙可能不支持HTTP/2。



### 8）使用断路器模式处理局部故障

* **断路器：RPI过程中调用的代理，在连续失败次数超过指定阈值后的一段时间内，代理会立即拒绝其他调用。**
* 要合理地设计服务来**防止在整个应用程序中故障的传导和扩散**，需要解决两个部分：
  * **必须让远程过程调用代理有正确处理无响应服务的能力**
  * **需要决定如何从失败的远程服务中恢复**

* **开发可靠的远程过程调用代理**：
  * **网络超时**：在等待针对请求的响应时，**不要做成无限阻塞，而是设定一个超时**，保证不会一致在无响应的请求上浪费资源。
  * **限制客户端向服务器发出请求的数量**：把客户端能够向特定服务发起的请求设置一个上限，**超过上限的请求立刻失败**。
  * **断路器模式**：监控客户端发出请求的成功和失败数量，若**失败比例超过一定阈值，则启动断路器让后续调用立刻失效**。在一定时间后，客户端将重新尝试，**若调用成功则解除断路器**。

* **从服务失效故障中恢复**：
  * 一种选择是**服务只是向客户端返回错误**，通过API Gateway汇总多个服务的响应，向客户端反馈错误。
  * 其他情况下，**返回备用值**（fallback value，如默认值和缓存响应）



### 9）服务发现

* 服务发现的关键组件是**服务注册表**，它是包含服务实例网络位置信息的一个数据库。服务实例启动和停止时，服务发现机制会更新服务注册表。当客户端调用服务时，服务发现机制会查询服务注册表并将请求路由到其中一个服务实例。
* **应用层服务发现模式：应用程序的服务和客户端与服务注册表进行交互**。包含**自注册模式**和**客服端发现模式**。
  * **自注册模式**：**服务实例调用服务注册表的注册API注册网络位置，提供运行状况检查URL**，服务注册表定期调用该URL验证服务实例状态，**且可要求服务实例定期调用heartbeat API防止注册过期**。
  * **客户端发现模式**：当客户端要调用服务时，会**查询服务注册表以获取服务实例列表**。为了提高性能，客户端可能会缓存服务实例，并使用负载均衡算法选择服务实例。
  * **弊端**：需要**为每种编程语言提供服务发现库**、需要**开发者负责设置和管理服务注册表**。

* **平台层服务发现模式**：现代部署平台都有内置的服务注册表和服务发现机制，**部署平台为每个服务提供DNS名称、虚拟IP（VIP）和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由至可用服务实例**。即服务注册、发现、路由过程完全由部署平台管理。包含**第三方注册模式**和**服务端发现模式**。
  * **第三方注册模式**：由第三方负责处理注册，不由服务本身负责。
  * **服务端发现模式**：**客户端不再查询服务注册表，而是向DNS名称发出请求，对该DNS的请求被解析到路由器，路由器查询服务注册表并对请求进行复杂均衡。**
  * **好处**：**服务发现的所有方面均由部署平台处理**，服务端和客户端不包含任何服务发现代码，**可适用于任何语言和框架**。
  * **弊端：仅限支持使用该平台部署的服务**



### 10）基于异步消息模式的通信

* 消息由**消息头部**和**消息主题**组成，消息头部包含**唯一消息ID以及可选的返回地址**，用于指定发送回复的消息通道，**消息正文是以文本或二进制格式发送的数据**。
  * **文档**：**仅包含数据的通用消息**，接收者决定如何解释它，常用于对命令式消息的回复。
  * **命令**：**等同于RPC请求的消息**，指定要调用的操作和参数。
  * **事件**：**表示发送方发生了重要的事件**，通常是领域事件，表示领域对象的状态更改。

* **消息通道**：发送方的业务逻辑调用发送端接口（封装底层通信机制），发送端由消息发送适配器类实现，通过消息通道向接收器发送消息，调用接收器中的消息处理程序适配器来处理消息。
  * **点对点通道**：向正在从通道读取的一个消费者传递消息，实现一对一交互方式。
  * **发布-订阅通道**：将一条消息发送给所有订阅的接收方，实现一对多交互方式。

* **使用消息机制实现交互方式**：消息机制支持所有交互方式。

  * **实现请求/响应和异步请求/响应**：消息机制本质是异步的，但客户端可能会阻塞等待回复，以实现请求/响应。

    <img src="https://4ever.web3img.com/2022/04/12/image.png" width=450 align="left">

  * **实现单向通知**：客户端将消息（通常是命令式消息）发送提高到服务所拥有的点对点通道。
  * **实现发布/订阅**：将消息发送到多个接收方读取的发布-订阅通道。
  * **实现发布/异步响应**：客户端发布一条消息，在消息头部指定回复通道。消费者将包含关联ID的回复消息写入回复通道，客户端通过ID来收集响应。



### 11）为基于消息机制的服务API创建API规范

* **记录异步操作：**

  * **请求/异步响应式API**：包括服务的**命令消息通道**、服务接受的**命令式消息的具体类型和格式**，以及服务发送的**回复消息的类型和格式**。

  * **单向通知式API**：包括服务的**命令消息通道**，以及服务接收的**命令式消息具体类型和格式**。

    <img src="https://4ever.web3img.com/2022/04/12/image77764c97fd88c680.png" width=450 align="left">

* **记录事件发布**：服务还可以使用**发布/订阅的方式向外发布事件**，此API风格的规范包括**事件通道**和服务发布到通道的**事件式消息的类型和格式**。



### 12）消息代理

<img src="https://4ever.web3img.com/2022/04/12/imagef7bfc37d13e17b06.png" align="left" width=450>

* **无代理架构**：服务直接交换消息。常用无代理消息技术**ZeroMQ**。

  * **好处**：允许更轻的网络流量和更低的延迟、消除消息代理可能成为性能瓶颈或单点故障的可能性、具有较低的操作复杂性，不需要设置和维护消息代理。
  * **弊端**：服务需要了解彼此位置，必须使用服务发现、由于发送接收方必须同时在线，导致可用性降低、实现确保消息成功传递等复杂功能困难。
  * 可用性降低和必须使用服务发现等弊端，与使用同步请求/响应的弊端相同，因此常用带消息代理的架构

* **消息代理架构**：消息代理作为发送方和接收方的中介。

  * **消息代理技术有多种，选择时考虑因素**：支持的编程语言是否较多、是否支持多种消息标准、**能否保留消息顺序**、提供什么样的消息投递保证、消息是否持久化到磁盘且代理崩溃时恢复、接收方重新连接至代理，是否能收到断开时的消息、**消息代理可扩展性如何**、端到端延迟、消息代理是否支持竞争性接收等。

  * **使用消息代理实现消息通道**：

    <img src="https://pic.dogimg.com/2022/04/12/6255164b8d10f.png" alt="1649743413969.png" title="1649743413969.png" align="left" width=450/>

  * **好处**：松耦合，无需服务发现，客户端不需要指导服务实例地址、消息缓存、支持所有通信方式、明确的进程间通信。
  * **弊端**：潜在性能瓶颈、潜在单点故障、额外的操作复杂性，消息系统必须独立安装、配置和运维。



### 13）消息代理的设计难题

* **处理并发和消息顺序**：挑战之一是如何在保留消息顺序的同时，横向扩展多个接收方的实例。常见的解决方案是**分片**：

  * 分片通道由多个分片组成，每个分片类似于一个通道

  * 发送方在消息头部指定分片键，消息代理使用分片键将消息分配给特定的分片

  * 消息代理将多个接收方实例组合在一起，视为相同的逻辑接受方（如Kafka中的消费者组），消息代理将每个分片分配给单个接收器。**将特定订单的每个事件都发布到同一个分片，就能保证被同一个接收方实例读取，保证顺序**。

    <img src="https://pic.dogimg.com/2022/04/12/625518f790ca9.png" alt="1649744097540.png" title="1649744097540.png" width=450 align="left"/>

* **处理重复消息**：大多数消息代理承诺**至少成功传递一次消息**。解决方式有两种：

  * **编写幂等消息处理器**：满足幂等的消息处理程序可以被放心执行多次，只要保证消息顺序。

  * **跟踪消息并丢弃重复消息**：当应用程序逻辑非幂等或消息顺序无法保证，必须使用跟踪消息并丢弃重复消息的方式。简单方式是将消息ID入库，收到消息时进行判断，处理或丢弃。另一站方式是消息处理程序在应用程序表而不是专门表中记录Message ID。

    <img src="https://pic.dogimg.com/2022/04/12/62551b77100b1.png" alt="1649744738766.png" title="1649744738766.png" width=450 align="left"/>

* **事务性消息**：服务通常需要在更新数据库的事务中发布消息，数据库更新和消息发布都必须在事务中进行。**传统解决方法是在数据库和消息代理之间使用分布式事务**，但消息代理部分不支持，如Kafka。

  * **使用数据库表作为消息队列**：**可靠地发布消息的直接方式是应用事务性发件箱模式**。而如何将消息从数据库移动到消息代理并对外发布有2种不同方法。

    <img src="https://4ever.web3img.com/2022/04/12/image6b4391e69cd5ec14.png" alt="image6b4391e69cd5ec14.png" border="0" align="left" width=450>

  * **通过轮询模式发布事件**：Message Relay定期查询OUTBOX表。弊端在于可能造成数据库开销，因此更好的做法是**拖尾数据库事务日志**。

  * **使用事务日志拖尾模式发布事件**：让Message Relay拖尾数据库的事务日志文件（提交日志）。事务日志挖掘器读取事务日志条目，将对应插入消息的每个相关日志转换为消息，并发布到消息代理，此方法适用于写入关系型数据库或NoSQL记录的消息。该方案有许多实际应用案例和实现可参考：**Debezium（适配Kafka）、Linkedin Databus（适配Oracle）、DynamoDB Streams、Eventuate Tram（适配Mysql binlog协议、Postgres WAL和Kafka）。**

    <img src="https://4ever.web3img.com/2022/04/12/imaged7c2f078bfb05ea7.png" alt="imaged7c2f078bfb05ea7.png" border="0" align="left" width=350>



### 14）使用异步消息提供可用性

* **同步消息会降低可用性**：同步消息由于必须等待服务端返回响应，将导致降低应用程序的可用性，为了最大化系统的可用性，应该设法最小化系统的同步操作量。

* **消除同步交互**：尽管无法将所有服务都改为异步API，但仍然有一些方法在不发出同步调用请求的情况下处理同步的调用请求。

  * **使用异步交互模式**：在可能的情况下将交互改为异步交互，服务端的响应放置于消息通道中，直到服务端处理完成并将回复放置于通道中，才给予客户端响应。

    <img src="https://4ever.web3img.com/2022/04/12/imagea6461946933e4084.png" alt="imagea6461946933e4084.png" border="0" align="left" width=450>

  * **复制数据**：服务维护一个数据副本，在处理查询等请求时使用。而数据的源头则在数据变化时发出消息，服务端订阅这些消息来确保数据副本的实时更新。缺点在于若复制数据量太大，会导致效率低下，且没有从根本上解决服务如何更新其他服务所拥有的数据这个问题。

    <img src="https://pic.dogimg.com/2022/04/12/6255250410b75.png" title="1649747131600.png" align="left" width=450/>

  * **让服务暂缓与其他服务交互**：仅使用本地的数据完成请求的验证——>更新本地数据库并向OUTBOX插入消息——>向客户端返回响应——>服务异步发送消息，让其他服务协同。**好处在于即使后续协同的服务中断，直接相关联的服务也能向客户端发出响应，且最终其他服务会重启并根据消息进行协同工作。弊端在于使得客户端更复杂，且丢失部分检验。**

    <img src="https://pic.dogimg.com/2022/04/12/6255261242ea8.png" alt="1649747453718.png" title="1649747453718.png" align="left" width=500/>



## （四）使用Saga管理事务

### 1）微服务架构下对分布式事务的需求

* 不同于**单体应用**中使用单个数据库，只需要加上**Spring注解@Transactional注解**即可保障事务的ACID，**微服务架构下**数据分布于多个服务，分布于多个数据库，**需要一种机制来保障多数据环境下的数据一致性。**

  <img src="https://4ever.web3img.com/2022/04/12/imageb49bc70128dca1af.png" alt="imageb49bc70128dca1af.png" border="0" align="left" width=400>



### 2）分布式事务的挑战

* 在多个服务、数据库和消息代理之间**维持数据一致性的传统方法是采用分布式事务**。分布式事务的管理的事实标准是**X/Open Distributed Transaction Processing（DTP）Model，即X/Open XA。**XA采用**两段式提交（two phase commit，2PC）**来保证事务的所有参与方要么同时完成，要么失败时同时回滚。
* XA对技术栈有要求，**需要符合XA标准的数据库、消息代理、数据库驱动、消息API以及用来传播XA全局事务ID的进程间通信机制**。分布式事务的一个问题是**许多新技术包括NoSQL并不支持XA标准，一些流行的消息代理如RabbitMQ和Kafka也不支持分布式事务。**
* 分布式事务的**另一个问题在于它的本质是同步进程间通信，这无疑会降低分布式系统的可用性。**为了让一个分布式事务完成提交，所有参与方都必须可用。
* CAP理论中证明，系统只能在一致性、可用性、分区容错性中选择其他两个，目前**主流架构师倾向于保证系统的可用性，降低系统对强一致性的需求。**



### 3）使用Saga模式维护数据一致性

* 一个Saga表示需要更新多个服务中数据的一个系统操作，**Saga由一连串的本地事务组成**，每一个本地事务负责更新所在的数据库，**Saga使用异步消息来协调一系列本地事务**，从而维护多个服务之间的数据一致性，即使Saga的参与方暂时不可用，也能确保最终所有步骤被执行。

* 系统操作启动Saga的第一步，**完成本地事务后触发下一个本地事务的执行**。相比较于ACID事务，Saga缺乏隔离性，且Saga必须使用补偿事务来回滚Saga。

  <img src="https://4ever.web3img.com/2022/04/12/image150243fb2f97f923.png" alt="image150243fb2f97f923.png" border="0" width=400 align="left">

* **Saga无法自动回滚，因为每个本地事务都只关联自己的数据库，因此必须编写补偿事务**。如表4-1所示，前3个步骤可能会失败，因此需要提供补偿事务，它们也被称为**可补偿性事务**。第4步骤后都是不可能失败的步骤，因此后两个步骤称为**可重复性事务**，第4步称为**关键性事务**。

  <img src="https://4ever.web3img.com/2022/04/12/image54483e694b3af5e0.png" alt="image54483e694b3af5e0.png" border="0" width=400 align="left">



### 4）Saga的协调模式

* Saga的实现包含协调Saga步骤的逻辑，当系统命令启动Saga时，**协调逻辑必须选择并通知第一个Saga参与方执行本地事务，等事务完成Saga协调选择并调用下一个Saga参与方。如果任何本地事务失败，则Saga协调补偿事务的执行。**

* **协同式Saga：把Saga的决策和执行顺序逻辑分布在Saga的每一个参与方中，Saga参与方订阅彼此的事件并做出相应的响应。**

  * **可靠的事件通信**：在实现基于协同的Saga时，必须考虑与服务间通信相关的问题。第一个问题是**确保Saga参与方将更新数据库和发布事件作为数据库事务的一部分，因此必须使用事务性消息**。第二个问题是**确保Saga参与方能够接收到每个事件映射到自己的数据上，让Saga参与方发布包含相关性ID的事件**。

  * **正常业务执行顺序**：

    <img src="https://4ever.web3img.com/2022/04/12/image63ee2a320abccb2c.png" alt="image63ee2a320abccb2c.png" border="0" align="left" width=550>

  * **业务回滚执行顺序：**

    <img src="https://4ever.web3img.com/2022/04/12/image3b7425539de67244.png" alt="image3b7425539de67244.png" border="0" align="left" width=550>

  * **好处**：**简单**，服务在创建、更新或删除业务对象时发布事件；**松耦合**，参与方订阅事件并且彼此之间不会因此产生耦合。
  * **弊端**：**更难理解**，协调式Saga的逻辑分布在每个服务的实现中，难以理解；服**务之间的循环依赖关系**，Saga参与方订阅彼此的事件，可能会导致循环依赖关系；**紧耦合的风险**，每个Saga参与方都需要订阅所有影响它们的事件。

* **编排式Saga：Saga编排器使用命令/异步响应方式与Saga的参与方服务通信，通过Saga编排器向参与方发送命令式消息指导参与方的操作。当参与方完成操作后，将向Saga编排器发送答复消息。**

  * 正常情况下的执行流程如下，虽然Saga编排器是Order Service的一个组件，但是为了保持一致性，Saga依旧将Order Service视为另一个参与方。

    <img src="https://4ever.web3img.com/2022/04/12/image06efac0d7bb1a33c.png" alt="image06efac0d7bb1a33c.png" border="0" align="left" width=550>

  * 由于Saga的场景不止一个，使用Saga**状态机**是描述场景，建模Saga编排器的好方法。

    <img src="https://4ever.web3img.com/2022/04/12/image7dbcf9235de96539.png" alt="image7dbcf9235de96539.png" border="0" width=550 align="left">

  * 与协同式Saga一致，编排式Saga的每个步骤都包括更新数据库和发布消息的服务，因此服**务必须使用事务性消息**。
  * **好处**：**更简单的依赖关系**，不会引入循环依赖关系，编排器调用参与方，而参与方不调用编排器，只有编排器依赖于参与方；**较少的耦合**，服务只实现供编排器调用的API，不知道Saga参与方发布的事件；**改善关注点隔离，减化业务逻辑**，Saga的协调逻辑本地化在Saga编排器。
  * **弊端**：在编排器中存在集中过多业务逻辑的风险，为了避免可以设计只负责排序的编排器。



### 5）解决Saga的隔离问题

* Saga只满足ACD三个属性，不满足隔离性。**这是因为每个Saga的本地事务所作的更新会立即被其他Saga所看到，可能导致其他Saga在执行时修改该Saga所访问的数据，或者其他Saga在Saga完成更新之前读取其数据导致暴露不一致数据**。缺乏隔离可能导致数据库异常，即多个事务并发执行与顺序执行时的结果不同。
* **缺乏隔离导致的问题：**
  * **丢弃更新**：一个Saga没有读取更新，而是直接覆盖了另一个Saga所做的更改。
  * **脏读**：一个Saga读取了尚未完成的Saga所做的更新。
  * **模糊或不可重复读**：一个Saga的两个不同步骤读取相同的数据却获得了不同的结果，因为另一个Saga已经进行了更新。

* **Saga模式下实现的隔离的对策**：
  * **语义锁**：Saga的**可补偿性事务会在其创建或更新的任何记录中设置状态**，该标志表示该记录未提交且可能发生更改，用于阻止其他事务访问记录的锁，也可以指示其他事务应该谨慎处理该记录。**Saga处理被锁定的记录，可以让系统命令执行失败并告诉客户端稍后再试**，缺点是使客户端变得更加复杂，需要实现重试逻辑。**或者让Saga处于阻塞状态，直到其他Saga释放语义锁**。虽然实现了ACID和客户端不必重试，但应用程序必须管理锁，且实现死锁检测算法。
  * **交换式更新**：**将更新操作设计为可以按照任何顺序执行。**
  * **悲观视图**：**重新排序Saga的步骤，以最大限度地降低由于脏读而导致的业务风险。**
  * **重读值**：防止丢失更新，**Saga在更新之前重新读取记录，若记录已更改，则Saga将中止并可能重新启动**。
  * **版本文件**：**记录对数据执行的操作，以便对它们进行重新排序，将不可交换操作替换为可交换操作。**
  * **业务风险评级**：基于业务风险选择并发机制，使用Saga执行低风险请求，使用分布式事务执行高风险请求。



## （五）微服务架构中的业务逻辑设计

### 1）业务逻辑组织模式

* **使用事务脚本模式设计业务逻辑**：脚本通常位于服务类中，每个服务类都有一个用于请求或系统操作的方法，方法实现该请求的业务逻辑。而数据对象是纯数据，几乎没有行为。高度面向过程，适用于简单业务逻辑。

  <img src="https://4ever.web3img.com/2022/04/13/image.png" alt="image.png" border="0" align="left" width=500>

* **使用领域模型模式设计业务逻辑**：业务逻辑由对象模型和相对较小的一些类的网络组成，通常直接对应问题域中的概念。方法和私有状态都存在领域对象中。这样的设计易于理解和维护，其次面向对象设计更容易测试，每个类可以被独立测试，且面向对象的设计更容易使用设计模式扩展。

  <img src="https://4ever.web3img.com/2022/04/13/imagefd6fd62b3e07864d.png" alt="imagefd6fd62b3e07864d.png" border="0" align="left" width=450>



### 2）关于领域驱动设计

* **DDD中的一些基本元素：**
  * **实体Entity**：具有持久化ID的对象，具有相同属性值的两个实体仍是不同对象，在Java EE中使用@Entity进行持久化的类通常是DDD实体。
  * **值对象**：作为值计集合的对象，相同属性值的两个值对象可以互换。
  * **工厂**：负责实现对象创建逻辑的对象或方法，可以隐藏被实例化的具体类。
  * **存储库**：用来访问持久化实体的对象，封装了访问数据库的底层机制。
  * **服务**：实现不属于实体或值对象的业务逻辑的对象。

* **传统领域模型的缺点**：**传统的领域模型由一组类和它们之间的关系组成，缺乏每个业务对象的明显的边界**，如何划定边界是由开发人员拍脑袋决定的。而缺少明确边界会在更新业务对象时导致问题，如**典型的业务对象具有一些不变量，即业务规则。直接更新业务对象的一部分可能会导致违法业务规则。**

  <img src="https://4ever.web3img.com/2022/04/13/imagebfe7620e35e295f3.png" alt="imagebfe7620e35e295f3.png" border="0" align="left" width=450>

* **聚合拥有明确的边界：聚合是一个边界内的领域对象的集群，可以被视为一个单元进行处理，它由根实体和可能的一个或多个其他实体和值对象组成。**

  * 聚合将领域模式分解为块，**单独的每一块更容易理解。它还阐明了加载、更新、删除等操作的范围。**
  * 在聚合上**调用更新操作会强制执行各种不变量约束**。此外，可以使用**版本号或数据库级锁定聚合根来处理并发性。**

  <img src="https://4ever.web3img.com/2022/04/13/imaged5a0951d5f19b883.png" alt="imaged5a0951d5f19b883.png" border="0" align="left" width=450>

* **聚合的规则**：

  * **只引用聚合根：要求聚合根是唯一可以由外部类引用的部分，客户端只能调用聚合根上的方法来更新聚合。该规则可以确保聚合能够强制执行各种不变量约束。**

  * **聚合间的引用必须使用主键而不是对象引用**：使用标识（如主键）而不是对象引用**意味着聚合是松耦合的，确保聚合之间的边界可以得到很好的定义，避免意外更新不同的聚合**。此外，**如果聚合是另一个服务的一部分，则不会存在跨服务引用对象的问题**；聚合同时也是存储的单元，**这种方式让持久化变得简单，可以更容易地将聚合存储在NoSQL数据库中**。通过主键引用聚合，**不再需要透明延迟加载，也避免它带来的问题，通过分片聚合来横向扩展数据库也相对简单。**

    <img src="https://4ever.web3img.com/2022/04/13/imagef3614d5b2582a9c1.png" alt="imagef3614d5b2582a9c1.png" border="0" align="left" width=450>

  * **在一个事务中，只能创建或更新一个聚合**：**确保单个事务的范围不会超过服务的边界，还满足大多数NoSQL数据库的受限事务模型**。虽然这个规则**让创建或更新多个聚合的操作变得更加复杂，但Saga可以解决这个问题**。当然，**在单个服务中维护多个聚合的一致性可以打破聚合规则，在一个事务中更新多个聚合，前提是这几个聚合在一个服务的数据库中，且支持复杂事务模型的数据库，如关系型数据库。**

    <img src="https://4ever.web3img.com/2022/04/13/image778e71c8fa8bd044.png" alt="image778e71c8fa8bd044.png" border="0" align="left" width=450>

* **聚合的粒度**：聚合理想上应该很小，**由于聚合的更新是序列化的，更细力度的聚合将提高应用程序能够同时处理的请求数量，提高可扩展性**。同时，**它降低了两个用户尝试更新同一个聚合而引发冲突的可能性，改善了用户体验。**但是，**聚合是事务的范围，可能需要定义更大的聚合使特定的聚合更新操作满足事务的原子性。**

* **使用聚合设计业务逻辑**：在典型的微服务中，**大部分业务逻辑由聚合组成，其余业务逻辑存在领域服务和Saga中**。**Saga编排本地事务的序列，确保数据的一致性。服务是业务逻辑的入口，由入站适配器调用。服务使用存储库从数据库中检索聚合或将聚合包存到数据库，每个存储库由访问数据库的出站适配器实现。**

  <img src="https://4ever.web3img.com/2022/04/13/image640d08d9475610eb.png" alt="image640d08d9475610eb.png" border="0" align="left" width=500>



### 3）发布领域事件

* 在领域驱动设计DDD的上下文中，**领域事件是聚合发生的事情，由领域模型中的一个类表示，通常代表状态的变化（聚合在被创建或发生重大更改）**。

* **发布领域事件的必要性**：考虑以下场景
  * **使用基于编排的Saga维护服务之间的数据一致性。**
  * **通知维护数据副本的服务，源数据已经发生更改。这种方法被称为命令查询职责隔离CQRS。**
  * **通过WebHook或消息代理通知不同的应用程序，以触发下一步业务流程。**
  * **按顺序通知同一应用程序的不同组件，如将WebSocket消息发送到用户的浏览器或更新ElasticSearch。**
  * 向用户发送短信或电子邮件通知。
  * 监控领域事件以验证应用程序是否正常运行。
  * 分析领域事件，为用户行为建模。

* **领域事件增强**：领域事件通常具有元数据，如事件ID和时间戳，可能还包含执行了此次更改的用户的身份。在以下场景中：正在编写一个处理Order领域事件的事件接收方，之前定义的OrderCreated事件类涵盖了已发送事件的本质，但是在**处理时接收方可能需要订单的详细信息，一种选择是从Order Service中检索，让事件接收方查询聚合服务，缺点是产生服务请求的开销**。另一种则是**事件增强，事件直接包含接收方需要的消息，不再需要发起额外的查询。缺点是使领域事件的稳定性降低，接受方的需求发生变化时，事件类很可能需要跟着修改，降低了可维护性。**不过在大多数情况下，在事件中应该包含哪些属性是相当明显的。

* **识别领域事件**：

  * 通常软件的需求会描述需要发送通知的场景，表明存在一个领域事件。

  * 另一种方法是**事件风暴**。事件风暴是一种以事件为中心的研讨会，用于理解复杂的领域。事件风暴的结果是一个以事件为中心的领域模型，它由聚合和事件组成。

    1. **头脑风暴**：请求领域专家集体讨论领域事件，以橙色便笺表示，按时间轴顺序排放。
    2. **识别事件触发器**：请求领域专家确定每个事件的触发器，蓝色便笺表示用户操作，紫色便笺表示外部系统。同时还包含其他的领域事件。
    3. **识别聚合**：请求领域专家识别那些使用命令的聚合并发出相应的事件，用黄色便笺表示聚合。

    <img src="https://4ever.web3img.com/2022/04/14/image.png" alt="image.png" border="0" align="left" width=450>

* **生成领域事件**：从概念上讲领域事件由聚合负责发布，聚合知道状态何时变化以及要发布的事件，聚合可以直接调用消息传递API。缺点在于，**聚合不能使用依赖注入（会破坏聚合规则），所以消息传递API需要作为方法参数传递，从而使基础设施和业务逻辑交织在一起，并不可取**。**更好方法是在聚合和调用它的服务之间分配职责，服务可以使用依赖注入来获取对消息传递API的引用，从而轻松发布事件。**聚合可以通过几种不同方式将事件返回服务：
  * 在聚合方法的返回值中包括一个事件列表，服务调用聚合根的方法，获取事件并发布。
  * 在聚合根的一个内部字段中累积保存事件，服务检索这些事件并发布。

* **可靠地发布领域事件**：服务必须使用事务性消息来发布事件，以确保领域事件是作为更新数据库聚合的事务的一部分对外发布。为了使服务只发布跟自己有关的事件，可让服务实现带有泛型的超类，定义聚合类型和领域事件的标识接口类型。

* **消费领域事件**：领域事件最终作为消息发布到消息代理，接受方使用事件处理的客户端API处理。



## （六）使用事件溯源开发业务逻辑

### 1）传统持久化技术的问题

> 传统持久化技术将类映射到数据库表，将类的字段映射到数据表中的列，将类的实例映射到数据表中的行。

* **对象与关系的“阻抗失调”**：关系型数据的表格结构模式，与领域模型及其复杂关系的图状结构之间，存在基本的概念不匹配问题。例如Person类的子类Student和Teacher，部分属性是不同的，若数据存在同一个表Person，则Student数据行中对应Teacher类的属性将为空；若数据存在两个表中，则增删改查都要在两个表中进行。这一切都是源于“对象”和“关系”天生在概念上的不对等造成的。
* **缺乏聚合的历史**：传统持久化只存储聚合的当前状态，聚合更新后，先前的状态将被丢弃。
* **实施审计功能将非常繁琐且容易出错**：许多应用程序必须维护审计日志，用于跟踪哪些用户更改了聚合。负责记录审计日志的代码可能会与业务逻辑代码发生偏离，从而导致各种错误。
* **事件发布凌驾于业务逻辑之上**：无法将自动发布消息作为更新数据库事务的一部分，开发人员必须自己处理事件生成的逻辑，可能导致与业务逻辑代码不完全同步的情况。



### 2）什么是事件溯源

* 事件溯源是**构建业务逻辑和持久化聚合的另一种选择**，它**将聚合以一系列事件的方式持久化保存。每个事件代表聚合的一次状态变化，应用程序通过重放事件来重新创建聚合的当前状态。**

* 事件溯源是一种以事件为中心的技术，用于实现业务逻辑和聚合的持久化。**聚合作为一系列事件存储在数据库中，聚合的业务逻辑围绕生成和使用这些事件的要求而构建**。

* **事件溯源通过事件来持久化聚合**：事件溯源采用基于领域事件的概念来实现聚合的持久化，将每个聚合持久化为数据库中的一系列事件（事件存储）。**当应用程序创建或更新聚合时，它会将聚合发出的事件插入到EVENTS表中。应用程序通过从事件存储中检索并重放事件来加载聚合，包括加载聚合的事件——>使用默认构造函数创建聚合实例——>调用apply()遍历事件。**

  <img src="https://4ever.web3img.com/2022/04/14/imageb608c31ce6e2462c.png" alt="imageb608c31ce6e2462c.png" border="0" align="left" width=450>

* **事件代表状态的改变**：使用事件溯源时，事件不再可有可无，每当聚合的状态发生变化时，它必须发出一个事件。因此，**事件中必须包含聚合执行状态变化所需的数据**。

  <img src="https://4ever.web3img.com/2022/04/14/image95723659f2d0057c.png" alt="image95723659f2d0057c.png" border="0" align="left" width=350>

* **聚合方法都与事件相关**：业务逻辑通过调用聚合根上的命令方法来处理对聚合的更新请求。在传统的应用程序中，命令方法通常会验证参数，然后更新一或多个聚合字段。而基于事件溯源的应用程序的命令方法则通过生成事件来起作用。

  * 事件溯源**将命令方法重构成两个或多个方法**，第一个方法（如process方法）接收命令对象参数，然后**返回表示状态更改的事件列表**。其他方法（如apply方法）将特定事件类型作为参数来更新聚合。值得注意的是，执行这些方法不会失败，因为事件代表一个**已经发生的状态变化**。

    <img src="https://4ever.web3img.com/2022/04/14/imagea447e4340be0509e.png" alt="imagea447e4340be0509e.png" border="0" align="left" width=400>

  * **创建聚合的步骤**：使用聚合的默认构造函数实例化聚合根——>调用process方法生成新事件——>遍历新生成的事件并调用apply方法更新聚合的状态——>将新事件保存在事件存储库中。

  * **更新聚合的步骤**：从事件存储库加载聚合事件——>使用默认构造函数实例化聚合根——>遍历加载的事件，在聚合根上调用apply方法——>调用process方法以生成新事件——>遍历新生成的事件并调用apply来更新聚合的状态——>将新事件保存在事件存储库中。

* **使用乐观锁处理并发更新**：两个请求同时更新同一聚合的情况并不少见，**乐观锁通常使用版本列来检测聚合从读取以来是否已更改**。只有当前版本和应用程序读取聚合时的版本一致时，更新才会成功。**事件存储库也可以使用乐观锁来处理并发更新，每个聚合实例都有一个与事件一起读取的版本号，当应用程序插入事件时，事件存储会验证版本是否未更改**，简单的可将事件数作为版本号。

* **事件溯源和发布事件**：使用轮询或事务日志拖尾。

  * **轮询**：挑战在于如何确定哪些事件是新事件，事务可以按照与生成事件不同的顺序提交，因此可能意外跳过事件。解决方法是在event表中添加一个额外的列，跟踪事件是否已发布。轮询是查找未发布的事件，将这些事件发布到消息代理后，再将事件标记为已发布。

    <img src="https://4ever.web3img.com/2022/04/14/imaged64aa2bfbff1925f.png" alt="imaged64aa2bfbff1925f.png" border="0" align="left" width=450>

  * **使用日志拖尾技术来可靠地发布事件**：日志拖尾技术可以保证事件会被发布，并且具备高性能和可扩展性。

* **使用快照提高性能**：长生命周期的聚合可能含有大量事件，加载和重放这些事件会变得越来越低效。常见解决方案是定期持久保存聚合状态的快照。

  <img src="https://4ever.web3img.com/2022/04/14/imagee1d94f860298e71f.png" alt="imagee1d94f860298e71f.png" border="0" align="left" width=400>

<img src="https://4ever.web3img.com/2022/04/14/image5c93aaddcd61a0c4.png" alt="image5c93aaddcd61a0c4.png" border="0" align="left" width=550>

* **幂等方式的消息处理**：消息代理很可能多次传递相同的消息，因此最好保证消息接受方的处理逻辑是幂等的。
  * **基于关系型数据库**：**将已处理消息的ID插入process_message表中，作为插入event表的事件的事务的一部分**。若出现重复消息ID，则可以直接丢弃。
  * **基于非关系型数据库**：由于非关系型数据库的事务模式功能有限，**不像关系型数据库可以通过ACID事务来原子化同时完成事件持久化和记录消息ID**，因此需要采取别的方式。可以**将消息ID存储在处理它时生成的事件中，通过验证聚合的所有事件中是否包含该消息ID来做重复检测。**为了避免处理一些消息可能不会生成事件，导致缺少该消息记录，从而导致错误。需要始终发布事件，在处理不生成事件的消息时，生成包含消息ID的伪事件，事件接收方则忽略它。

* **领域事件的演化**：事件溯源在概念上会永久存储事件，一方面提供了准确的更改信息的审计日志，使应用程序可以重建聚合的历史状态；另一方面，**事件的结构经常随着时间的推移而变化**。因此，应用程序需要处理多个事件版本，事件订阅者可能会看到多个版本。

  * **事件结构的演化**：事件溯源应用程序的结构分为三个层次，由一个或多个聚合组成、定义每个聚合发出的事件、定义事件的结构。为了处理非向后兼容的更改，事件溯源可以使用“向上转换”的方式，从事件存储库加载事件时执行转换，将各个事件从旧版本更新，应用程序代码只需处理当前事件结构。

    <img src="https://4ever.web3img.com/2022/04/14/image92d09b1318f4c8d8.png" alt="image92d09b1318f4c8d8.png" border="0" align="left" width=500>

* **事件溯源好处**：

  * **可靠地发布领域事件**：它为事件驱动的微服务架构提供可靠的基础，只要聚合状态发生变化，就可以可靠地发布事件。同时存储更改操作的用户身份，为审计提供帮助。事件流还可以用于通知用户、应用程序集成、分析和监控等。
  * **保留聚合的历史**：可以轻松实现检索聚合过去状态的查询。
  * **最大限度地避免对象和关系的“阻抗失调”问题**：服务可以通过序列化复杂聚合的状态对它进行快照，会在聚合与序列化表示之间增加一个间接层次。
  * **为开发者提供一个”时光机“**：事件溯源存储了应用程序生命周期中发生的所有事件的历史记录。例如，传统应用程序无法做到，客户将商品添加到购物车后又将其删除，对这一部分客户进行促销或优惠。因为传统应用程序不会保留此项记录。但事件溯源的应用程序可以做到。

* **事件溯源的弊端**：
  * 这类编程模式具有一定的学习曲线
  * **基于消息传递的应用程序的复杂性**：消息代理确保至少一次成功传递，意味着非幂等事件处理前必须检测并丢弃重复事件。
  * **处理事件的演化有一定难度**：由于事件是永久存储的，意味着聚合可能需要处理与多个结构版本相对应的事件。解决方法是之前提到的向上转换。
  * **删除数据存在一定难度**：由于事件溯源的目标之一就是保留聚合的历史，它的目的就是永久存储数据，**因此删除数据的传统方法是进行软删除，即设置以删除标志**。但部分法规授予个人用户对数据的擦除权，要求必须彻底删除用户的个人信息。**一些个人信息可能被存储在事件中，或者作为聚合的主键。对事件溯源应用程序的挑战在于不删除事件的情况下清除特定的用户信息。**
    * 加密事件可以解决大多数删除用户个人信息的问题，每个用户有一个加密密钥，该密钥存储在单独的数据库表库中，应用程序使用该加密密钥加密包含用户个人信息的任何事件。当用户请求删除时，应用程序从数据表库表中删除加密密钥记录。由于事件无法被解密，则用户个人信息被有效删除。
    * 若个人信息被用作聚合ID，则丢弃加密密钥还不够。解决方案是使用假名，用UUID替代例如电子邮件地址作为聚合ID，将UUID与电子邮件地址的关联存储在数据库表中，删除时可以将UUID与电子邮件地址的关联直接删除。
  * **查询事件存储库非常有挑战性**：有些复杂查询必须使用包含嵌套SQL以及通过设置初始值并重放事件来获得。解决方案可以使用CQRS来实现查询。



### 3）实现事件存储库（举例Eventuate Local实现原理）

* 事件存储库是数据库和消息代理功能的组合。它有表现为数据库的一面，因为它具有通过主键插入和检索聚合事件的API。它有表现为消息代理的一面，因为它有用于订阅事件的API。

* 可以选择专用事件存储库，如Axon（用于开发事件溯源和CRQS的事件驱动应用程序的Java框架）、Eventuate Local（基于Kafka和关系型数据库）。

* **Eventuate Local的事件数据库结构**：EVENTS存储事件、ENTITES每个实体一行、SNAPSHOTS存储快照。

  <img src="https://pic.dogimg.com/2022/04/15/625848bb28847.png" alt="1649952928879.png" title="1649952928879.png" align="left" width=500/>

* **Eventuate Local表结构**：

  * events表中，triggering_event列用于检测重复的事件或消息，存储处理生成此事件的消息或事件ID。

    <img src="https://4ever.web3img.com/2022/04/14/image956c5a8ca7a656d8.png" alt="image956c5a8ca7a656d8.png" border="0" align="left" width=250>

  * entites表存储每个实体的当前版本，使用乐观锁，每次更新实体时，都会更新entity_version列。

    <img src="https://4ever.web3img.com/2022/04/14/image75545a5f2dfead0e.png" alt="image75545a5f2dfead0e.png" border="0" align="left" width=250>

  * snapshots表存储实体快照。

    <img src="https://4ever.web3img.com/2022/04/14/imagee47b72456a3a125c.png" alt="imagee47b72456a3a125c.png" border="0" align="left" width=300>

* **Eventuate Local表结构支持的操作**：
  * **find()**：该操作查询snapshots表检索最新的快照，若存在则查询events表以查找event_id大于快照的entity_version的所有事件。否则，将检索指定实体的所有事件。find()操作还参与update()操作的验证实体版本。
  * **create()**：该操作将一行插入entites表，并将事件插入events表中。
  * **update()**：该操作将事件插入events表中，且负责乐观锁，即更新entity_version。

* **通过订阅Eventuate Local的事件代理接收事件**：服务通过订阅事件代理来使用事件，事件代理具有每个聚合类型的主题。**聚合ID被用作分区键，保留给定聚合发布的事件的顺序**。要接收来自聚合的事件，服务要订阅聚合的主题。

* **Eventuate Local的事件中继把事件从数据库传播到消息代理**：事件中继将插入事件数据库的事件传播到事件代理，使用事务日志拖尾或轮询。
  * **事件中继连接到MySQL服务器，通过读取MySQL binlog对数据库进行同步更新**。
  * 事件中继部署为独立进程，**会定期将当前在binlog的位置保存到一个特殊的Kafka主题中**，在启动时，它首先从主题检索最后记录的位置，从该位置开始读取binlog。



### 4）使用Eventuate Local的Java客户端框架

<img src="https://4ever.web3img.com/2022/04/14/image6936d05d6beffd34.png" alt="image6936d05d6beffd34.png" border="0" align="left" width=500>

* ReflectiveMutableCommandProcessingAggregate抽象类，作为聚合的基类，含有2个泛型参数<聚合类，聚合命令类>。它使用反射将命令和事件分派给适当的方法。

* Order聚合类继承自抽象类，Order entends 抽象类<Order, OrderCommand>
* OrderCommand接口继承自基础接口Command，是Order聚合的命令基础接口。CreateOrder是Order命令的具体类。
* OrderEvent接口继承自基础接口Event，是Order聚合的事件基础接口。OrderCreated是Order事件的具体类。

* AggregateRepository含有2个泛型参数<聚合类，聚合命令类>，提供三个重载方法save、update、find。
* 使用@EventSubscriber注解持久化订阅方的ID，@EventHandleMethod注解将特定方法标识为事件处理程序，事件处理程序具有一个EventHandlerContext泛型类参数，包含事件与元数据。



### 5）同时使用Saga和事件溯源

* **使用编排式Saga的挑战性**：
  * **Saga创建**：启动Saga的服务必须以原子方式创建或更新聚合，并同时创建Saga编排器
  * **Saga编排器**：一个Saga编排器必须以原子方式消费回复消息，更新状态并发送命令式消息。
  * **Saga参与方**：Saga的参与方服务，必须自动接收消息、检测和丢弃重复消息、创建或更新聚合，以及发送回复消息。
* **使用事件溯源方式实现协同式Saga**：事件溯源的事件驱动属性使得实现基于协同式的Saga非常简单。当聚合被更新时，它会发出一个事件。不同聚合的事件处理程序可以接收该事件，并更新该聚合。事件溯源框架自动使每个事件处理程序具有幂等性。
  * **弊端**：在这种场景下，事件体现了双重目的。事件溯源使用事件来表示状态更改，但是使用事件实现Saga协同，需要聚合即使没有状态更改也必须发出事件。

* **创建编排式Saga**：Saga编排器由服务的方法创建，服务的方法会执行两项操作：创建或更新聚合，并创建Saga编排器。而关键在于服务必须保证这两个操作是事务性的。

  * **当使用关系型数据库作为事件存储库时**：服务可以在同一个ACID事务中更新事件存储库并创建Saga编排器。例如使用Eventuate Local和Eventuate Tram Saga

    <img src="https://4ever.web3img.com/2022/04/14/imagea6bb6c2d4c0b9325.png" alt="imagea6bb6c2d4c0b9325.png" border="0" align="left" width=450>

  * **当使用非关系型数据库作为事件存储库时**：使用NoSQL数据库时，可能受限于事务模型功能，应用程序无法以原子方式更新事件存储库并创建Saga编排器。**相反，服务必须具有一个事件处理程序，该事件处理程序将创建Saga编排器来响应聚合发出的领域事件。同时，要保证该事件处理器的幂等的，避免创建多个Saga实例。**可从事件的唯一属性中导出Saga的ID，如**使用事件的聚合的ID**（适用于响应聚合创建事件而创建的Saga）、或**使用事件ID作为Saga ID**。**这种方式同样适用于关系型数据库的事件存储库创建Saga**，好处是松耦合，保证服务不再直接实例化Saga。

    <img src="https://4ever.web3img.com/2022/04/14/image082bc53175577f56.png" alt="image082bc53175577f56.png" border="0" align="left" width=450>

* **实现基于事件溯源的Saga参与方**：需要解决以下问题

  * **命令式消息的幂等处理**：由于Saga参与方在处理消息时生成的事件中记录消息ID，在更新聚合时，Saga参与方通过在事件中查找消息ID来验证它之前是否处理过该消息。

  * **以原子方式发送回复消息**：原则上，Saga编排器可以订阅聚合所发出的事件。但这存在2个问题，一是Saga命令可能不会改变聚合，此时聚合不会发出事件，Saga编排器也就收不到回复消息。二是这种方法需要Saga编排器区别处理使用事件溯源的Saga参与方和不使用事件溯源的Saga参与方。**更好的方法是让Saga参与方继续向Saga编排器的回复通道发送回复消息。**通过以下两步：

    1. 当Saga命令处理程序创建或更新聚合时，它会安排将SagaReplyRequested伪事件与聚合发出的实际事件一起保存在事件存储库中。

    2. SagaReplyRequested伪事件的事件处理程序使用事件中包含的数据构造回复消息，然后将其写入Saga编排器的回复通道。

       <img src="https://4ever.web3img.com/2022/04/15/image.png" alt="image.png" border="0" align="left" width=500>

* **实现基于事件溯源的Saga编排器**：必须解决三个关键设计问题：如何**持久化一个Saga编排器**？如何**以原子方式更改编排器的状态并发送命令式消息**？如何**确保Saga编排器只处理一次回复消息**？

  * **使用事件溯源持久化Saga编排器**：Saga编排器的生命周期从创建到被更新以响应Saga参与方的回复。可以使用以下事件来持久化Saga编排器。Saga编排器在创建和更新时发出对应事件，这些事件包含重新创建Saga编排器状态所需的数据。
    * **SagaOrchestratorCreated**：Saga编排器已创建。
    * **SagaOrchestratorUpdated**：Saga编排器已更新。

  * **可靠地发送命令式消息**：Saga编排器使用两步发送命令，使用这种方式可以确保命令至少发送一次。

    1. 一个Saga编排器为它想要发送的每个命令发出一个SagaCommandEvent。包含发送命令所需要的所有数据，包括目标通道和命令对象。事件存储与事件存储库中。
    2. 事件处理程序处理这些事件，并将命令式消息发送到目标信息通道。

    <img src="https://4ever.web3img.com/2022/04/15/imagef59237e96169f8da.png" alt="imagef59237e96169f8da.png" border="0" align="left" width=450>

  * **确保只处理一次回复消息**：Saga编排器同样可以使用回复消息的ID存储在处理回复时发出的事件中，然后可以轻松确定消息是否重复。进行检测并丢弃重复的回复消息。



## （七）在微服务架构中实现查询

### 1）使用API组合模式进行查询

* **API组合模式通过调用拥有数据的服务并组合结果来实现查询操作**。包含两种类型参与者：

  * **API组合器**：通过查询数据提供方的服务来实现查询操作。
  * **数据提供方服务**：拥有查询返回的部分数据的服务。

  <img src="https://4ever.web3img.com/2022/04/17/image.png" alt="image.png" border="0" align="left" width=400>

* **API组合模式的设计缺陷**：

  * **由谁来担任API组合器的角色**：

    * 第一种选择是**由服务的客户端扮演API组合器的角色**。但对于防火墙之外的客户以及通过较慢网络访问的服务不太适用。

      <img src="https://4ever.web3img.com/2022/04/17/imaged4813c5e758faad8.png" alt="imaged4813c5e758faad8.png" border="0" align="left" width=300>

    * 第二种选择是**由实现应用程序外部API的API Gateway来扮演API组合器的角色**。此时API Gateway不是将请求路由到另一个服务，而是实现API组合逻辑。

      <img src="https://4ever.web3img.com/2022/04/17/image249785b968546a66.png" alt="image249785b968546a66.png" border="0" align="left" width=300>

    * 第三种选择是**将API组合器实现为独立服务**。

      <img src="https://4ever.web3img.com/2022/04/17/image1fa89cbbdbb1fbe4.png" alt="image1fa89cbbdbb1fbe4.png" border="0" align="left" width=300>

  * **API组合器应该适用响应式编程模式**：API组合器应尽可能并行调用提供方服务、最大限度缩短查询操作的响应事件。为了让API组合器达到较高的可维护性、性能和可扩展性，应该适用基于Java CompletableFuture、RxJava可观测或其他类似的响应式设计。

* **API组合模式的弊端**：API组合模式的好处在于实现查询操作简单直观，但不可忽视的是这种模式带有一定的弊端。
  * **增加了额外的开销**：需要调用多个服务和查询多个数据库，需要更多计算和网络资源，运行应用程序的成本也相应增加。
  * **带来可用性降低的风险**：可用性随着所涉及的服务数量而下降。可采用一些策略来提高可用性。一种策略是**API组合器在提供方服务不可用时，返回先前缓存的数据**。另一种策略是让**API组合器返回不完整的数据**。
  * **缺乏事务数据一致性**：针对多个数据库执行查询，会带来查询操作返回不一致数据的风险。



### 2）使用CQRS模式

* **命令查询职责隔离CQRS，使用事件来维护从多个服务复制数据的只读视图，借此实现对来自多个服务的数据的查询**。

* **使用CQRS的原因**：针对一些涉及多个服务的查询，API组合模式无法有效地实现。更重要的是，实现一些特定的服务查询很有挑战性，也许服务的数据库不能有效支持查询或有些服务必须检索不同服务所拥有的数据的查询。

  * **API组合模式无法有效实现的多服务查询**：例如findOrderHistory查询操作，包含consumerId、pagination、filter参数。**首先不是所有服务都存储用于过滤或排序的属性**。一种解决方案是**让API组合器进行内存中连接，但是需要API组合器来检索和连接大规模的数据集，相当低效**。另一种解决方案是**让API组合器先从包含过滤属性的服务检索数据，再通过ID等从其他服务请求数据。但是只适用于服务具有支持批量查询时，否则单独请求在网络流量大的情况下效率低下。**

    <img src="https://4ever.web3img.com/2022/04/17/image7c0043e1371a1e23.png" alt="image7c0043e1371a1e23.png" border="0" align="left" width=450>

  * **单一服务查询的挑战**：**拥有数据的服务不适合查询**或有时**服务的数据库不能有效支持查询**。例如findAvailableRestaurants查询操作，关键在于执行有效的地理空间查询。但并非所有数据库都支持地理数据模式。单个服务查询难以实现的另一个原因是，**拥有数据的服务有时并不是实现查询的服务**。根据隔离问题，数据的服务方可能并不负责查询功能。

* **在微服务架构中实现查询经常会遇到的三个问题（API组合模式）**：
  * **使用API组合模式检索分散在多个服务中的数据会导致昂贵、低效的内存中连接**。
  * **拥有数据的服务将数据存储在不能有效支持所需查询的表单或数据库中。**
  * **隔离问题的考虑意味着，拥有数据的服务不一定是会实现查询的服务。**

* **CQRS介绍**：Command Query Responsibility Segregation命令查询职责隔离，它将持久化数据模型和使用数据的模块分为两部分：命令端和查询端。**命令端模块和数据模型实现创建、更新和删除操作（CUD），查询端模块和数据模型实现查询。查询端通过订阅命令端发布的事件，使其数据模型与命令端数据模型保持同步。**

  <img src="https://4ever.web3img.com/2022/04/17/imageffe1c6fa0da3ca24.png" alt="imageffe1c6fa0da3ca24.png" border="0" align="left" width=450>

* **CQRS与查询专用服务**：查询服务的API只包含查询操作，无命令操作。通过订阅其他服务发布的事件来确保数据库的不断更新。

  <img src="https://4ever.web3img.com/2022/04/17/imagea79f11b853719ad1.png" alt="imagea79f11b853719ad1.png" border="0" align="left" width=450>

* **CQRS的好处**：
  * **在微服务架构中高效地实现查询**：CQRS有效地实现了检索多个服务所拥有数据的查询。使用易于查询的CQRS视图将更有效，该视图预加载和预处理了来自多个服务的数据，避免API组合模式中大规模数据的昂贵低效的内存中连接。
  * **高效地实现多种不同的查询类型**：使用单个持久化数据模型支持所有查询通常具有挑战性，即使数据库具有支持特定类型查询的扩展，使用专用数据库通常也更有效。CQRS通过定义多个视图来避免单个数据存储的限制，有效地实现特定查询。
  * **在基于事件溯源技术的应用程序中实现查询**：事件溯源的事件存储库仅支持基于主键的查询，而通过CQRS模式订阅基于事件溯源的聚合发布的事件流，可以保持最新的聚合的多个视图，解决此限制。
  * **更进一步的实现问题隔离**：领域模型及其相应的持久化数据模型不必同时处理命令和查询。CQRS模式为服务的命令端和查询端定义了单独的代码模式和数据库模式，通过问题隔离，命令端和查询端更简单且易于维护。同时，CQRS使实现查询的服务和拥有数据的服务不同，由另一个专用服务来实现关键高吞吐量的查询更加合理。

* **CQRS的弊端**：
  * **更加复杂的架构**：开发人员必须编写更新和查询视图的查询端服务。管理和运维额外的数据存储库提高运维的复杂性。此外，应用程序可能使用不同类型的数据库，进一步增加开发人员和运维人员的复杂性。
  * **处理数据复制导致的延迟**：CQRS会导致命令端和查询端视图之间的滞后。**一种解决方案是采用命令端和查询端API为客户提供版本信息**，使其判断查询端是否过时，让其轮询查询端视图直至它是最新的。**另一种解决方案是用户界面通过在针对聚合的命令执行成功后，更新本地版本的领域模式**，而不必发出查询来克服复制带来的延迟。缺点是用户界面必须复制服务端代码。



### 3）设计CQRS视图

* **数据访问模块实现数据库访问逻辑，事件处理程序和查询API模块使用数据访问模块来更新和查询数据库。事件处理程序模块订阅事件并更新数据库，查询API模块负责实现查询API。**

  <img src="https://4ever.web3img.com/2022/04/17/image15743d6739adfa11.png" alt="image15743d6739adfa11.png" border="0" align="left" width=350>

* **选择视图存储库**：关键的设计决策是**数据库的选择和数据库结构的设计**，数据库和数据库模型的**主要目的是有效地实现视图模块的查询操作**，**查询的特征是选择数据库的首要考虑因素**，数据库还必须有效地实现由事件处理程序执行的更新操作。

  * **SQL还是NoSQL数据库**：NoSQL通常是CQRS视图的一个很好选择，CQRS可以利用它们的优势并忽略弱点，**受益于NoSQL更丰富的数据模型和性能**，且不受其事务处理能力的限制，因为CQRS仅需要使用简单的事务并执行一组固定的查询即可。同时，SQL数据库也具有出色的性能且较为令人熟悉，且CQRS可能需要使用SQL数据库才能支持报表引擎。

    <img src="https://4ever.web3img.com/2022/04/17/image194d3a53c8baadb3.png" alt="image194d3a53c8baadb3.png" border="0" align="left" width=450>

  * **支持更新操作**：事件处理程序通常使用其主键更新或删除视图数据库的记录，或使用类似外键的做法来更新或删除记录。某些类型的数据库能够有效支持基于外键的更新操作，如关系型数据库或MongoDB。但DynamoDB等一部分NoSQL仅支持基于主键的更新或删除，要实现同等功能必须查询DynamoDB的二级索引。

* **设计数据访问模块**：该模块由数据访问对象DAO及其辅助类组成，DAO实现由事件处理程序调用的更新操作，以及查询模块调用的查询操作。DAO把上层代码映射到数据库API使用的数据类型，同时它还必须处理并发更新并确保更新的幂等的。
  * **并发处理**：如果视图订阅由单个聚合类型发布的事件，则不会出现任何并发问题，因为特定的聚合实例发布的事件是按顺序处理的。若视图订阅由多个聚合类型发布的事件，则多个事件处理出现可能同一时间更新同一记录。如果DAO通过读取记录并进行更新，再写入已更新记录的方式，则必须使用乐观/悲观锁；若DAO通过更新数据库记录而不是先读取它们，则当不同的事件处理程序更新不同属性时，则可以更新记录的单个项目。
  * **幂等事件处理程序**：为了确保可靠，事件处理程序必须记录事件ID并原子化更新数据存储区。如果使用SQL数据库，则事件处理程序可以将已处理的事件作为更新视图事务的一部分插入PROCESSED_EVENTS表中。如果使用有限事务模型的NoSQL数据库，则事件处理程序必须将事件保存在它更新的数据存储区记录中。注意，事件处理程序并不需要记录每个事件ID，若事件ID单调递增等。

* **添加和更新CQRS视图**：有时需要增加新视图以支持新查询，或重建视图基于架构的更改。
  * **使用归档事件构建CQRS视图**：消息代理无法无限期存储消息，因此只能通过从消息代理读取所有需要的事件来构建视图。相反，应用程序还必须读取已存档的旧事件，这些旧事件可能被保存到AWS S3上，还需要通过使用可扩展的大数据技术来实现此目的。
  * **增量式构建CQRS视图**：处理所有事件所需要的事件和资源随着时间的推移而不断增长，最终视图创建将变得缓慢和昂贵。解决方案是使用两步增量算法，第一步基于先前的快照和自创建快照以来发生的事件，定期计算每个聚合实例的快照。第二步使用快照和任何后续事件创建视图。



## （八）外部API模式

### 1）外部API的设计难题

* **多次客户端请求导致用户体验不佳**：

  * 应用程序有时必须发出多个请求来检索所需要的数据，**应用程序与服务之间的频繁交互可能使应用程序看起来无响应**。尤其是使用互联网或移动网络时，延迟通常是局域网的百倍；

  * 虽然应用程序可以通过同时执行请求来最小化延迟，**但某些情况下，客户端必须按顺序执行请求**，仍旧带来糟糕用户体验。

  * 它可能要求客户端的开发人员编写复杂的API组合代码，而客户端开发人员的首要任务应该是创建优质的用户体验。

    <img src="https://4ever.web3img.com/2022/04/18/imaged74acf73d6ec4bd0.png" alt="imaged74acf73d6ec4bd0.png" border="0" align="left" width=450>

* **缺乏封装导致前端开发做出的代码修改影响后端**：随着应用程序的发展，服务开发人员有时会以破坏现有客户端的方式更改API，甚至将系统分解为服务。但是，如果将有关于服务的知识融入客户端中，则很难更改服务的API。客户端的更改耗时周期长且不可强制其更改。
* **服务可能选用对客户端不友好的进程间通信机制**：在防火墙外部的客户端应用程序通常使用HTTP和WebSockets等协议，但其他如gRPC和AMQP等协议在局域网内运行良好，却无法在客户端中使用，甚至无法穿透防火墙。



### 2）API Gateway模式

* API Gateway是一种服务，是外部API客户端进入基于微服务应用程序的入口点，它负责请求路由、API组合和身份验证等功能。

  * **请求路由**：API Gateway通过将请求路由到相应的服务来实现一些API操作。类似于Nginx提供的反向代理功能。

    <img src="https://4ever.web3img.com/2022/04/18/image03efc37aad2a8478.png" alt="image03efc37aad2a8478.png" border="0" align="left" width=450>

  * **API组合**：提供粗粒度API，使客户端可以通过单个请求检索原本需要多个请求组合的数据。
  * **协议转换**：它可以为外部客户端提供RESTful API，即使应用程序服务在内部使用混合协议，包括REST和gRPC。
  * **API Gateway能够为每一个客户端提供它们专用的API**：API Gateway可以提供单一的API，适用于公共API。同时，API Gateway可以为每个客户端提供自己的API，为每种客户端实现定制化。
  * **实现边缘功能**：包括身份验证、访问授权、速率限制、缓存、指标收集、请求日志等。边缘功能可选在后端实现、在API Gateway的上游实现（增加多一次请求条约）、在API Gateway实现。

* **API Gateway架构**：

  <img src="https://4ever.web3img.com/2022/04/18/imagedec4ab9018b35c1f.png" alt="imagedec4ab9018b35c1f.png" border="0" align="left" width=450>

* **API Gateway的所有者模式**：谁应该负责API Gateway的开发与运维？一种选择是由单独团队负责，弊端是它与SOA的ESB团队类型，从事客户端开发的人员需要访问特定服务必须向API Gateway团队提交请求并等待他们公开API。更好的方式是**让客户端团队拥有与他们有关的API模块并公开，API Gateway团队负责开发公共模块和API Gateway的运维**。为了更好工作，API Gateway的部署流水线应该完全自动化，客户端团队不必等待手工部署。

  <img src="https://4ever.web3img.com/2022/04/18/imagedbc71fa23fc669bd.png" alt="imagedbc71fa23fc669bd.png" border="0" align="left" width=450>

* **后端前置模式**：为每种类型的客户端实现单独的API Gateway。理论上可以使用不同的技术栈开发不同的API Gateway，公共层的功能由API Gateway实现的共享库提供。好处是**明确界定职责，构建者即管理者、API模块彼此隔离，提供可靠性、不会互相影响，提高可观测性、每个API可独立扩展，且每个API Gateway更小。**

  <img src="https://4ever.web3img.com/2022/04/18/image69cc554ff545bde6.png" alt="image69cc554ff545bde6.png" border="0" align="left" width=450>

* **API Gateway的好处**：它**封装了应用程序的内部结构**，客户端不必调用特定服务，而是与API Gateway通信。API Gateway**为每个客户端提高特定于客户端的API**，**减少客户端与应用程序之间的往返次数，简化客户端代码**。

* **API Gateway的弊端**：它是一个必须另外开发、部署和管理的高可用组件，开发人员必须更新API Gateway才能对外公开服务的API，因此要求API Gateway的更新过程尽可能轻量化。

* **API Gateway的设计难题**：
  * **性能与可扩展性**：所有外部请求首先通过API Gateway，它的性能与可扩展性非常重要，**影响性能与可扩展性的关键设计决策是API Gateway应该使用同步还是异步I/O**。
    * **同步I/O模型**：**每个网络连接由专用线程处理**。但是，同步I/O的一个限制是操作系统线程是重量级的，因此**API Gateway可以拥有的线程数量和并发连接数量存在上限。**
    * **异步I/O模型**：单个事件循环线程将I/O请求分派给事件处理程序。在JVM上可以使用基于NIO的框架，如Netty、Spring Reactor等。非JVM选项是Node.js。非阻塞的I/O更具可扩展性，因为没有使用多个线程的开销，弊端是比基于异步回调的编程模型要复杂很多。
  * **使用响应式编程抽象**：一些后端服务请求可能依赖于其他服务请求的结果，一种解决方案是API端点处理程序方法按照依赖性确定的顺序调用服务。
    * **按顺序调用服务的弊端是服务响应时间过长，为了最小化响应时间，组合逻辑应尽可能同时调用服务。编写可扩展的并发代码的传统方式是使用回调，使用传统的异步回调方法编写API组合代码容易导致回调纠成一团**，难以理解，尤其是组合同时使用并发请求和顺序请求时。
    * **更好的方法是使用响应式方法，以声明式风格编写API组合代码。**JVM的响应式抽象包括：Java8 CompletableFuture、Project Reactor Monos。
  * **处理局部故障**：实现API Gateway可靠性的一种方法是在负载均衡器后运行多个API Gateway实例。另一种方式是API Gateway正确处理可能导致高延迟的请求，即启用断路器模式。
  * **成为应用程序架构中好公民**：与架构中的其他服务一样，API Gateway也必须实现整个架构中选择的各种模式，如服务发现模式，可观测性模式。



### 3）实现一个API Gateway

* **实现API Gateway的职责**：请求路由、API组合、边缘功能、协议转换、架构好公民。
* **实现API Gateway的方法**：使用现成API Gateway产品、使用API Gateway框架或Web框架开发自定义API Gateway。
* **现成API Gateway产品服务弊端分析**：
  * **AWS API Gateway**：不支持API组合，仅支持HTTP(S)且非常依赖JSON，仅支持服务发现模式。
  * **AWS Application Load Balancer**：没有实现基于HTTP方法的路由，不支持API组合和身份验证。
  * **使用产品化的API Gateway**：大部分产品都实现了边缘功能和路由功能，但基本都不支持API组合。
* **开发自己的API Gateway**：
  * **开发API Gateway需要解决两个关键设计问题**：
    * 实现定义路由规则的机制以简化复杂代码。
    * 正确实现HTTP代理行为，包括如何处理HTTP标头。
  * **因此，开发API Gateway最好的起点是使用满足上述目的的框架**。
    * **Netflix Zuul**：Zuul框架实现了边缘功能和路由功能，开发人员可以通过定义实现API组合的Spring MVC控制器来扩展Zuul。**Zuul的主要限制在于它只能实现基于路径的路由，无法将GET/orders和POST/orders路由至不同的服务，因此不支持CQRS查询架构。**
    * **Spring Cloud Gateway**：构建在基于NIO的JVM响应式框架Project Reactor上，属于响应式Web框架。Spring Cloud Gateway提供了简单且全面的方法来执行请求路由、实现执行API组合的请求处理程序、处理边缘功能等。



### 4）使用GraphQL实现API Gateway

* 实现支持多种客户端的REST API的API Gateway非常耗时，尤其是后端前置模式。因此考虑使用基于图形的API框架，如GraphQL，实现高效的数据提取。

* **基于图形的API框架关键思想**：服务器的API由基于图形的模式组成，内部定义了一组节点（类型），它们具有属性（字段）和与其他节点的关系。客户端通过执行查询来检索数据，该查询根据图的节点及其属性和关系指定所需的数据。最终，实现客户端在API Gateway的单词往返种检索所需的数据。

  <img src="https://4ever.web3img.com/2022/04/18/image42e6865c03a5d05c.png" alt="image42e6865c03a5d05c.png" border="0" align="left" width=450>

* **基于图形的API技术好处**：使客户能够控制返回的数据，让开发一个用来支持不同客户需求的灵活单一的API变得可行，显著减少开发的工作量。

* **基于图形的API技术**：分为Netflix Falcor和GraphQL，其中基于GraphQL的API Gateway使用Node.js Express Web框架和Apollo GraphQL服务器，用JavaScript编写。关键部分：

  * **GraphQL模式**：定义服务器端数据模型及其支持的查询。

  * **解析器函数**：解析函数将模式的元素映射到各种后端服务。

  * **代理类**：代理类调用应用程序的服务。

    <img src="https://4ever.web3img.com/2022/04/18/image49921e3de13fa605.png" alt="image49921e3de13fa605.png" border="0" align="left" width=550>



## （九）微服务架构中的测试策略（上）

### 1）微服务中有效的测试策略

* **手动执行测试的缺点**：需要引入自动化测试，是缩短交付周期的唯一方法。

  * **手动测试效率极低**，无法快速且安全地交付高质量软件
  * **在交付流程中才进行测试为时已晚**，更好的方式是让开发人员编写自动化测试，作为开发的一部分。

* **自动化测试**：通常包括四个阶段，自动化测试框架包括JUnit。

  1. **设置环境**：将被测系统以及其他相关元素组成的测试环境初始化为所需的状态。

  2. **执行测试**：调用被测系统。

  3. **验证结果**：对被调用的返回结果和被测系统的状态进行判断。

  4. **清理环境**：必要时清理测试环境。

     <img src="https://4ever.web3img.com/2022/04/18/imagea6e0fe0caae9eb84.png" alt="imagea6e0fe0caae9eb84.png" border="0" align="left" width=450>

* **使用模拟和桩进行测试**：被测系统在运行时通常会依赖另一些系统，通常采用测试替身来消除被测系统的依赖性。测试替身包括桩和模拟。模拟对象框架包括Mockito。

  <img src="https://4ever.web3img.com/2022/04/18/imageaee25c1861017ad5.png" alt="imageaee25c1861017ad5.png" border="0" align="left" width=400>

* **测试的不同类型**：验证应用程序或服务的功能。
  * **单元测试**：测试服务的一小部分，例如类。
  * **集成测试**：验证服务是否能与基础设施服务（如数据库）或其他应用程序服务进行交互。
  * **组件测试**：单个服务的验收测试。
  * **端到端测试**：整个应用程序的验收测试。

* **使用测试象限进行分类**：关注两个维度

  * **测试是面向业务还是面向技术**

  * **测试的目标是协助开发还是寻找产品缺陷**

    <img src="https://4ever.web3img.com/2022/04/18/imagefb2f9766b1f6205f.png" alt="imagefb2f9766b1f6205f.png" border="0" align="left" width=200>

* **使用测试金字塔指导测试工作**：在金字塔从下往上移动时，应该编写的测试越来越少，应该编写大量的单元测试和很少的端到端测试。

  <img src="https://4ever.web3img.com/2022/04/18/image277df12f3e92bda8.png" alt="image277df12f3e92bda8.png" border="0" align="left" width=350>



### 2）微服务架构中的测试挑战

* 进程间通信是微服务架构的核心，基于微服务的应用程序是一个分布式系统，团队不断开发他们的服务，并更新服务的API。服务开发人员必须编写测试，以验证其服务是否仍旧能与其依赖关系和客户端正常交互。

* 验证两个服务可以交互的一种方法是同时运行两个服务，调用触发通信的API，并验证它是否具有预期结果。这不仅会遇到集成的问题，且基本是端到端的。**解决方案是使用更好的消费者驱动的契约测试**。

* **消费者契约测试是针对提供者的集成测试，用于验证其API是否符合消费者的预期**。契约测试并不会测试提供者的业务逻辑，这是单元测试的范围。**消费者驱动的契约测试通常使用样例测试，消费者和提供者之间的交互由一组样例定义，称为契约**，每个契约都包含在一次交互期间交换的样例消息。

  <img src="https://4ever.web3img.com/2022/04/18/image74d6c4c26aa9aa14.png" alt="image74d6c4c26aa9aa14.png" border="0" align="left" width=450>

* **使用Spring Cloud的契约测试服务**：Spring Cloud Contract是Spring应用程序的消费者契约测试框架，为提供者程序生成契约测试，还为消费者集成测试配置模拟。

  <img src="https://4ever.web3img.com/2022/04/18/image5a2e2735edaa0772.png" alt="image5a2e2735edaa0772.png" border="0" align="left" width=450>

  <img src="https://4ever.web3img.com/2022/04/18/image988293a94c4e5c84.png" alt="image988293a94c4e5c84.png" border="0" align="left" width=400>

* **部署流水线**：每个服务都有一个部署流水线，作为将代码部署到生产环境的自动化过程。部署流水线通常使用持续集成服务器实现，如Jenkins。部署流水线通常包含以下阶段

  * **提交前测试阶段**：执行单元测试。
  * **提交测试阶段**：编译服务，执行单元测试，执行静态代码分析。
  * **集成测试阶段**：执行集成测试。
  * **组件测试阶段**：执行服务的组件测试。
  * **部署阶段**：将服务部署到生产环境。

  <img src="https://4ever.web3img.com/2022/04/18/imagef8eae0914b85cdfd.png" alt="imagef8eae0914b85cdfd.png" border="0" align="left" width=450>



### 3）微服务编写单元测试

* **单元测试分类**：
  * **独立型单元测试**：使用针对类的依赖性的模拟对象隔离测试类。
  * **协作型单元测试**：测试一个类及其依赖项。

* **六边形架构使用的单元测试类型**：包含以下测试对象和测试类型

  * **实体**：对实体进行**协作型单元测试**，可以彻底测试业务逻辑
  
  * **值对象**：普遍情况下值对象没有任何依赖，采用**独立型单元测试**。实体和值对象是服务的业务逻辑的基本构成单元。
  
  * **Saga**：**协作型单元测试**。对此类的测试会创建一个Saga，并验证它是否将消息按照预期的顺序发送给参与方。不仅需要测试正常执行的场景，还要为Saga回滚的各种场景编写测试。一种方法是编写使用真实数据库和消息代理以及桩服务的测试，以此来模拟Saga的参与方，但编写测试缓慢。**更好的方法是编写模拟与数据库和消息代理交互的类的测试。**
  
  * **领域服务**：服务的大多数业务逻辑通过实体、值对象和Saga实现，而领域服务类则完成业务逻辑的其余部分。常用测试是**独立型单元测试，并模拟存储库和消息传递类等依赖项。**包括**设置**（配置服务依赖项的模拟对象）、**执行**（调用服务方法）、**验证**（验证服务方法返回的值是否正确，以及是否已正确调用依赖项）。
  
  * **控制器**：控制器的有效测试策略是**模拟服务和存储库的独立型单元测试**。使用如Spring Mock Mvc框架编写的测试会产生模拟的HTTP请求，并对HTTP响应进行断言。可使用这些框架测试HTTP请求路由以及Java对象与JSON之间的转换，而无须真正的网络调用。
  
  * **事件和消息处理程序**：对消息适配器进行测试，消息传递的基础设施是基于桩的，不涉及消息代理。可使用如Eventuate Tram Mock Messaging框架等进行模拟消息测试。
  
    <img src="https://4ever.web3img.com/2022/04/18/image18ab4f0ffaa0b47a.png" alt="image18ab4f0ffaa0b47a.png" border="0" align="left" width=500>
  
  

## （十）微服务架构中的测试测量（下）

### 1）编写集成测试

<img src="https://4ever.web3img.com/2022/04/19/image.png" alt="image.png" border="0" align="left" width=500>

* 为了测试服务按预期工作，必须编写测试来**验证服务是否可以正确地与基础设施服务和其他应用程序服务进行交互。**一种方法是启动所有服务并通过调用API进行测试，但这是所谓的端到端测试。**更有效的策略是编写集成测试，并使用一些策略简化测试**。

  * 第一个策略是**测试每个服务的适配器，以及可能的适配器支持类**。

  * 第二个策略是**使用契约**。契约用于测试消费者和提供者，确保就API达成一致。

    * **消费者端测试**：用于消费者适配器，使用契约来配置桩，模拟提供者程序的行为，使得可以直接运行测试。
    * **提供者端测试**：用于提供者适配器，使用契约来测试适配器，使用模拟来满足适配器的依赖关系。

    <img src="https://pic.dogimg.com/2022/04/19/625e65da0235a.png" alt="1650353616780.png" title="1650353616780.png" align="left" width=500/>



### 2）针对持久化层的集成测试

* 编写持久化集成测试，以**验证服务的数据库访问逻辑是否按预期工作**。持久化集成测试每个阶段行为如下：
  * **设置**：通过创建数据库结构设置数据库，并将其初始化为已知状态，也可能开始执行一些必要的数据库事务。
  * **执行**：执行数据库操作。
  * **验证**：对数据库的状态以及从数据库检索的对象进行断言。
  * **拆解**：可选阶段，撤销对数据库所做的更改。
  * 需要解决的问题是如何**配置在持久化集成测试中使用的数据库**，比较有效的方法是**使用Docker**。



### 3）针对基于REST的请求/响应式交互的集成测试

* REST客户端和服务必须就REST API达成一致，包括**REST接口以及请求和响应主体的结构**。有效方式是使用**消费者驱动的契约测试**。客户端和服务的交互可以使用一组基于HTTP的契约来描述，每个契约都包含HTTP请求和响应。

  <img src="https://4ever.web3img.com/2022/04/19/imagefaaf993164b33a93.png" alt="imagefaaf993164b33a93.png" border="0" align="left" width=500>



### 4）针对发布/订阅交互的集成测试

* 服务通常会发布由一个或多个其他服务使用的领域事件，集成测试必须验证提供方及其消费方是否就消息通道和领域事件的结构达成一致。

  <img src="https://4ever.web3img.com/2022/04/19/imagec13755145c3cd883.png" alt="imagec13755145c3cd883.png" border="0" align="left" width=500>



### 5）针对异步请求/响应交互的集成测试

* 异步请求/响应的集成测试，一边是发送命令的服务，另一边是处理命令并发送应答的服务。它们必须就命令式消息通道的名称以及命令和回复消息的结构达成一致。

  <img src="https://4ever.web3img.com/2022/04/19/imageb9d1e0308b9c5f6e.png" alt="imageb9d1e0308b9c5f6e.png" border="0" align="left" width=500>



### 6）编写组件测试

* 为了验证整个服务是否按预期工作，进行组件测试。为了单独测试服务，组件测试必须为多个依赖服务配置桩，并且设置数据库和消息传递基础设施。
  * **进程内组件测试**：使用常驻内存的桩和模拟代替依赖项来运行服务。如Spring Boot测试框架。进程内组件测试编写起来较为简单，速度更快，但缺点是不测试服务的可部署性。
  * **进程外组件测试**：将服务打包为生产环境就绪的格式，并将其作为单独的进程运行。如将服务打包为Docker容器影像。进程外组件测试使用真实的基础设施服务，但是对应用程序的任何依赖项使用桩。优点是提高测试覆盖率，测试内容更接近部署内容。缺点是测试编写复杂，执行速度更慢，且必须弄清楚如何为应用程序服务设置桩。

* **如何为进程外组件测试编写桩服务**：

  * 一种选择是**使用Spring Cloud Contract**，可以编写为组件测试配置桩的契约。缺点是这些契约只能由组件测试使用，且它的重点是消费者契约测试，包含契约的JAR文件必须部署在Maven存储库中，处理涉及动态生成的值的交互也具有挑战。
  * 另一种选择是**在测试内部配置桩**，例如可以使用配置好DSL的WireMock作为HTTP桩服务，以及对使用Eventuate Tram消息的服务的测试可以配置消息桩。

  <img src="https://4ever.web3img.com/2022/04/19/image14e76b09a2f6987f.png" alt="image14e76b09a2f6987f.png" border="0" align="left" width=500>



### 7）编写端到端测试

* 端到端测试由大量组件构成，必须部署多个服务以及基础设施服务。**为了控制端到端测试的数量，一个好的策略是编写用户旅程测试**。用户旅程测试对应于用户使用系统的过程，例如编写一个完成三项测试的单个测试，而不是分为三个测试来进行。显著减少必须编写的测试数量并缩短测试执行时间。



## （十一）开发面向生产环境的微服务应用

> 为了使服务做好部署到生产环境中的准备，需要确保满足三个关键的质量属性：**安全性、可配置性和可观测性**。



### 1）开发安全的服务

* 应用程序开发人员主要**负责实现安全性的四个不同方面**：
  * **身份验证：验证尝试访问应用程序的主体的身份**。主体的凭据包括用户的ID和密码，或应用程序的API密钥。
  * **访问授权：验证是否允许访问主体对指定数据完成请求的操作。应用程序通常使用基于角色的安全性和访问控制列表ACL的组合。**基于角色的安全性为每个用户分配一或多个角色，授予他们调用特定操作的权限。ACL授予用户或角色对特定业务对象或聚合执行操作的权限。
  * **审计：跟踪用户在应用中执行的所有操作**，以便检测安全问题，帮助客户实现并强制执行合规性。
  * **安全的进程间通信**：理想情况下，所有进出服务的通信都应该采用传输层安全性（TLS）加密，服务间通信甚至可能需要使用身份验证。



### 2）单体应用程序的安全性

* **传统单体应用程序的安全性流程**：用户使用其ID和密码登录时，客户端会向应用程序发出包含用户凭据的POST请求。应用程序验证凭据并将会话令牌返回给客户端。客户端在应用程序的每个后续请求中都包含会话令牌。示例中使用的安全框架是基于Java的Spring Security，可以处理身份验证和访问授权。

* 安全架构的一个关键部分是**会话，它存储主体的ID和角色**。传统的Java EE应用程序会话是HttpSession内存中会话。会话令牌代表着每一个具体的会话。

* 实现安全性的另一个关键是**安全上下文，它存储有关发出当前请求的用户的信息**。Spring Security将安全上下文存储在静态的线程局部变量中，**任何被调用以处理请求的代码都可以访问该变量**。请求处理程序可以调用SecurityContextHolder.getContext().getAuthentication()获取有关当前用户的信息。

  <img src="https://pic.dogimg.com/2022/04/19/625ed61df1ffd.png" alt="1650382363034.png" title="1650382363034.png" align="left" width=500/>

  <img src="https://pic.dogimg.com/2022/04/19/625ed7f7bdfe2.png" alt="1650382846425.png" title="1650382846425.png" align="left" width=500/>

* **单体应用程序使用的安全设计的缺点**：使用内存中会话的缺点在于必须把特定会话的所有请求路由到同一个应用程序实例，这个要求将使负载均衡和操作变得复杂。
  * 必须实现会话耗尽机制，在关闭应用程序实例前等待所有会话到期，以免丢失内存中已有的会话；或者将会话存储在数据库中。
  * 或者开发者完全不保存服务端会话，在应用程序的API客户端的每个请求中提供凭据，如API密钥和私钥。或者应用程序将会话状态存储在会话令牌中。



### 3）在微服务架构中实现安全性

* 为了在微服务架构中实现安全性，需要确定**谁负责验证用户身份以及谁负责访问授权**。
* **微服务架构无法从单体应用程序中借鉴设计思想**，因为单体应用程序的安全架构的一些方面是不适用于微服务架构的。
  * **内存中的安全上下文**：由于服务无法共享内存，因此无法使用内存中的安全上下文来传递用户身份。微服务需要一种不同的机制在服务间传递用户身份。
  * **集中会话**：由于内存中的安全上下文无意义，导致内存会话也没有意义，需要在微服务中使用不同的会话机制。

* **由API Gateway处理身份验证**：处理身份验证有两种不同的方法：

  * **一种选择是让各个服务分别对用户进行身份验证**，这种方法的**问题在于它允许未经身份验证的请求进入内部网络，依赖于每个开发团队在所有服务中正确实现安全性**，因此安全漏洞风险和概率较大。**另一个问题是不同的客户端以不同的方式进行身份验证，但我们要避免在服务中处理多种不同的身份验证机制**。

  * **更好的方法是让API Gateway在请转发给服务之前对其进行身份验证**。在API Gateway中进行集中API身份验证的优势在于**只需要确保这里的验证是正确的**，出现安全漏洞的可能较低。另一个好处是**不同的身份验证机制只需要在API Gateway处理**，使服务实现变得简单。

  * API Gateway调用的**服务需要知道发出请求的主体身份，它还必须验证请求是否通过身份验证**。解决方案是**让API Gateway在每个服务请求中包含一个令牌，服务使用令牌验证请求并获取有关主体的信息**。API Gateway可以为面向会话的客户端提供相同的令牌。

    <img src="https://4ever.web3img.com/2022/04/19/image6b7621a06b49aebd.png" alt="image6b7621a06b49aebd.png" border="0" align="left" width=500>

* **处理访问授权**：除了验证客户端的凭据，应用程序还必须实现访问授权机制，以验证是否允许客户端执行所请求的操作。
  * **实现访问授权的一个位置是API Gateway**，如果不允许用户访问特定路径，API Gateway在请求转发前就可以拒绝该请求（如Spring Security框架）。在API Gateway中集中实现访问授权可降低安全漏洞风险。**弊端是有可能产生API Gateway与服务之间的耦合**，并对它们要求以同步的方式进行代码更新，**且API Gateway只能实现对URL路径的基于角色访问**，实现对单个领域对象的访问授权通常是不实际的。
  * **另一个实现访问授权的位置是服务，服务可以对URL和服务方法实现基于角色的访问授权，还可以实现ACL来管理对聚合的访问**。

* **使用JWT传递用户身份和角色**：在微服务架构中实现安全性，**需要确定API Gateway使用哪种类型的令牌来将用户信息传递给服务**。有2种类型的令牌可以选择：
  * **一种选择是使用不透明，即无可读性的令牌**，通常是一串UUID。不透明令牌的**缺点是降低性能和可用性，并增加延迟。因为这种令牌的接收方必须对安全服务发起同步RPC调用，以验证令牌并检索用户信息。**
  * **另一种消除对安全服务调用的方法是使用包含有关用户信息的令牌，透明令牌的一个流行标准是JSON Web令牌（JWT）**。JWT是在访问双方之间安全地传递信息的标准方式，**JWT的内容包含一个JSON对象，包括用户的信息以及其它元数据。它使用仅为JWT的创建者所知的数字签名**，如API Gateway和JWT的接收者，确保恶意第三方不能伪造和篡改JWT。
    * JWT的一个问题是令牌是自包含的，不可撤销，也即**没有可行的方法来撤销落入恶意第三方的某个JWT令牌**。解决方案是**发布具有短效期的JWT，限制恶意第三方。但是短效JWT的缺点是应用程序必须以某种方式不断重新发布JWT以保持会话活动**。

* **在微服务架构中使用OAuth 2.0**：**OAuth 2.0可用于解决上述提到的短效JWT的问题**。它是一种访问授权协议，最初用于使公共云服务的用户能够授予第三方应用程序访问其信息的权限，但不必向第三方应用程序透露密码。**也可以用于应用程序的身份验证和访问授权**。

  * **OAuth 2.0的关键概念**：

    * **授权服务器**：提供用于验证用户身份以及获取访问令牌和刷新令牌的API。Spring OAuth是一个很好的构建OAuth 2.0授权服务器的框架。
    * **访问令牌**：授予对资源服务器的访问权限的令牌，格式取决于具体实现技术，如Spring OAuth使用JWT。
    * **刷新令牌**：客户端用户获取新的令牌的长效但同时可被撤销的令牌。
    * **资源服务器**：使用访问令牌授权访问的服务。
    * **客户端**：想要访问资源服务器的客户端，在微服务架构中，API Gateway是OAuth 2.0客户端。

  * **OAuth 2.0访问令牌到期刷新机制**：如果访问令牌到期或即将到期，API Gateway通过发出OAuth 2.0刷新授权请求来获取新的访问令牌，刷新授权请求发送给授权服务器，请求在包括刷新令牌，如果刷新令牌尚未过期或被撤销，则授权服务器返回新的访问令牌。API Gateway将访问令牌传递给服务并返回给客户端。

    <img src="https://4ever.web3img.com/2022/04/19/imagea7205b0b7ab640fa.png" alt="imagea7205b0b7ab640fa.png" border="0" align="left" width=500>

    <img src="https://4ever.web3img.com/2022/04/19/image82cf3289ba64aaa3.png" alt="image82cf3289ba64aaa3.png" border="0" align="left" width=500>

  * **OAuth 2.0不是实现安全性唯一方法，核心在于三个关键思想**：

    * API Gateway负责验证客户端身份
    * API Gateway和服务使用透明令牌来传递有关主体信息
    * 服务使用令牌获取主体的身份和角色



### 4）设计可配置服务

* 将特定环境的配置属性值硬写入可部署服务的代码中是没有意义的，因为环境是动态创建的。相反，**服务应该由部署流水线构建一次，并自动部署到多个环境中**；将几套可能的配置属性集硬写入源代码，使用Spring框架的配置文件机制在运行时选择，这样做也是没意义的，因为这会**引入安全漏洞，并限制可部署的位置**。此外，应该使用秘密存储机制安全的存储凭据等敏感数据，并且使用外部化配置模式为服务在运行时提供适当的配置属性。
* **外部化配置机制在运行时向服务实体提供配置属性值**，主要有2种方法：
  * **推送模型**：部署基础设施通过类似操作系统环境变量或配置文件，将配置属性传递给服务实例。
  * **拉取模型**：服务实例从配置服务器读取它所需要的配置属性。

* **使用基于推送的外部化配置**：推送模型依赖于部署环境和服务的协作，部署环境在创建实例时提供配置属性。通过将配置属性作为环境变量传递或使用配置文件。

  * Spring Boot的属性来源，靠前的来源可以覆盖后者

    1. 命令行参数
    2. SPRING_APPLICATION_JSON，包含JSON的操作系统环境变量或JVM系统属性
    3. JVM系统属性
    4. 操作系统环境变量
    5. 当前目录中的配置文件

  * 推送模型的一个限制是重新配置正在运行的服务很难或不可能。另一个限制是配置属性值存在分散在众多服务定义中的风险。

    <img src="https://4ever.web3img.com/2022/04/19/image10d2596147079f13.png" alt="image10d2596147079f13.png" border="0" align="left" width=450>

* **使用基于拉取的外部化配置**：拉取模型中，服务实例从配置服务器读取配置属性。

  * 配置服务器有多种方法，包括**版本控制系统**（如Git）、**SQL和NoSQL数据库**、**专用配置服务器**（如Spring Cloud Config Server， Hashicorp Vault，AWS Parameter Store）。

  * **使用配置服务器的好处**：

    * **集中配置**：所有配置属性都存储在一个位置，易于管理。且为了消除重复的配置属性，可以定义全局默认值。
    * **敏感数据的透明解密**：加密敏感数据是一种安全性最佳实践，某些配置服务器会在将属性返回给服务之前自动对其进行解密。
    * **动态重新配置**：服务可能会通过轮询的方式检测更新的属性值，并重新配置。

  * **使用配置服务器的缺点**：除非由基础设施提供，否则需要额外人力进行配置和运维。

    <img src="https://4ever.web3img.com/2022/04/19/imaged270a6adeea81952.png" alt="imaged270a6adeea81952.png" border="0" align="left" width=450>



### 5）设计可观测的服务

* 作为服务开发人员，必须实现多种模式使得服务易于管理和排错。**这些模式公开了服务实例的行为和健康状态，使得监控系统可以跟踪和可视化服务状态，并在出现问题时生成告警**。可以使用以下模式来设计可观测的服务：
  * **健康检查API**：公开返回服务运行状况的接口。
  * **日志聚合**：记录服务活动并将日志写入集中式日志记录服务器，该服务器提供搜索和告警。
  * **分布式跟踪**：为每一个在服务之间挑战的外部请求分配唯一ID，并跟踪请求。
  * **异常跟踪**：向异常跟踪服务报告异常，该异常跟踪服务可以对异常进行重复数据删除，向开发人员发出警报并跟踪每个异常的解决方案。
  * **应用程序指标**：服务运维指标，例如计数器和指标，并公开给指标服务器。
  * **审核日志记录**：记录用户操作。

* **使用健康检查API模式**：服务实例需要告诉部署基础设施它是否能够处理请求，一个好的解决方案是服务实现监控检查接口，如使用Spring Boot Actuator。**部署基础设施定期调用此接口以确定服务实例的运行状况，并在其运行状况不佳时执行相应操作。**
  * 健康检查通常测试服务与外部服务的连接，成功时返回健康响应。由于返回的响应信息包含敏感信息，**Spring Boot Actuator等框架允许配置健康接口响应中的详细级别**。
  * **实现健康检查接口**：实现健康检查接口的代码必须以某种方式确定服务实例的健康状态，包括验证是否可以访问其外部基础设施服务。而Spring Boot Actuator等框架会执行测试查询（JDBC）的健康检查、消息代理的健康检查等。还可以自定义健康检查行为。
  * **调用健康检查接口**：可以使用一些服务注册表（如Eureka）来调用健康检查接口，以确定是否将流量路由到服务实例。或配置Docker和Kubernetes调用健康接口。
  
* **使用日志聚合模式**：基于微服务架构的应用程序将日志分散在多个服务中，不利于使用日志进行故障排除。**解决方案是使用日志聚合，日志聚合流水线将所有服务实例的日志发送给集中式日志服务器，可以进行查看、搜索和分析日志，并可配置在日志中出现某些消息时触发的告警**。
  * **服务如何生成日志**：**使用流行的Java日志库**，如Logback、log4j、JUL、SLF4J。或者有日志库无法强制执行的某些更严格的日志记录要求时，可以**基于日志记录库定义自己的日志记录API**。**同时还需要确定记录的位置**，传统将日志框架配置为写入文件系统中的位置，当使用现代化部署技术，如容器时应该将日志输出到stdout，由部署基础设施决定如何处理服务的输出。
  * **日志聚合的基础设施**：**日志聚合的基础设施服务要负责聚合日志、存储日志以及让用户可以搜索日志。一种流行的日志记录基础设施是ELK套件**：
    * ElasticSearch：面向文本搜索的NoSQL数据库，用作日志记录服务器。
    * Logstash：聚合服务日志并将其写入ElasticSearch的日志流水线。
    * Kibana：ElasticSearch的可视化工具。

* **使用分布式追踪模式**：在微服务架构中排除故障并诊断这些性能问题具有挑战性，深入了解应用程序正在执行的操作的一种好方法是使用**分布式追踪，它记录处理有关处理请求所进行的服务树调用的信息**，包括开始时间和结束时间等。
  * 分布式追踪术语中，追踪表示外部请求，由一个或多个跨度组成。跨度表示操作，关键属性是操作的名称、开始时间和结束时间。跨度可以有一个或多个子跨度，表示嵌套操作。如顶层跨度可能表示API Gateway的调用，子跨度表示API Gateway对服务的调用。
  
  * **分布式追踪可以为每个外部请求分配一个唯一ID，服务可以在日志条目中包含请求ID，与日志聚合相结合使用，可以轻松查找特定外部请求的所有日志条目。**
  
  * 分布式追踪包含供每个服务使用的追踪工具类库和分布式追踪服务器，**追踪工具类库管理追踪和跨度，向出站请求添加追踪信息以及分布式追踪服务器报告追踪**。**分布式追踪服务器存储追踪信息，并提供可视化用户界面**。
  
  * **使用追踪工具类库**：追踪工具类库构建跨度树，并发送给分布式追踪服务器。为了避免服务业务逻辑和使用追踪工具类库检测逻辑耦合，更好的方法是使用基于AOP技术的框架（如Spring Cloud Sleuth）或使用拦截器。
  
  * **分布式追踪服务器**：分布式追踪服务器将跨度拼接在一起形成完整的追踪并存储在数据库中。流行的分布式追踪服务器是Zipkin。
  
    <img src="https://4ever.web3img.com/2022/04/19/image129427e3968bad2f.png" alt="image129427e3968bad2f.png" border="0" align="left" width=500>

* **使用应用程序指标模式**：指标服务手机各类指标数据，提供可视化和告警功能。

  * **收集服务层面的指标**：**基于Spring Boot的服务可以使用Micrometer Metrics库作为依赖项来收集并公布基本指标**，例如JVM指标。Spring Boot的自动配置功能负责配置指标库并对外公布指标，如果服务收集特定于应用程序的指标，则该服务仅需要直接使用Micrometer Metrics API。

  * **把指标发送给指标服务**：服务有2种方式向指标服务提供数据。**使用推送模型时，服务实例通过调用API将指标发送到指标服务。使用拉取模式，Metrics Service调用服务API，并从服务实例检索指标信息。**

    <img src="https://4ever.web3img.com/2022/04/20/image.png" alt="image.png" border="0" align="left" width=450>

* **使用异常追踪模式**：服务把产生的异常报告给中央服务，该服务对异常进行重复数据删除、生成警报并管理异常的解决方案。

  * 查看异常的传统方法是查看日志，或配置日志记录服务器，在日志文件在出现异常时进行发送警报。但是这类方法存在一些问题：
    * 日志文件以单行日志条目为导向，而异常由多行组成。
    * 没有机制来追踪日志文件中发生的异常的解决方案，必须手动将异常复制粘贴到问题追踪器中。
    * 可能存在重复的异常，但没有自动机制将它们视为异常。

  * **更好的方法是使用异常追踪服务，将服务配置为通过类似 REST API向异常追踪服务报告异常，异常追踪服务对异常进行重复数据删除、生成警报并管理异常的解决方案**。有几种方法可以将异常追踪集成到应用程序中，服务可以直接调用异常追踪服务的API，**更好的方法是使用异常追踪服务提供的客户端库，如HoneyBadger**。

    <img src="https://4ever.web3img.com/2022/04/20/imageca22566ea23e3f7c.png" alt="imageca22566ea23e3f7c.png" border="0" align="left" width=450>

* **使用审计日志模式**：审计日志记录的目的是**记录每个用户的操作，用于帮助客户支持、确保合规性并检测可疑行为**。有几种不同的方法来实现审计日志记录。
  * **向业务逻辑添加审计日志代码**：在服务的业务逻辑中使用审计日志代码。缺点是将审计日志代码和业务逻辑交织，降低可维护性。且容易出错，因为它依赖于开发人员来编写审计日志代码。
  * **使用面向切面编程**：使用AOP方法或框架来定义自动拦截每个服务的方法调用，并持久化审计日志条目。缺点是只能记录调用的方法名称和它的参数。因此确定正在执行的业务对象，并生成面向业务的审计日志条目具有挑战性。
  * **使用事件溯源**：事件溯源自动为创建和更新操作提供审计日志，需要在每个事件中记录用户身份。一个限制是不记录查询操作，若需要为查询创建日志条目，必须考虑其他选择。



### 6）使用微服务基底模式开发服务

* 微服务基底是一个框架或一组框架，可以处理很多问题，包括外部化配置、健康检查、应用程序指标、服务发现、断路器、分布式追踪等。它可以显著减少代码量，使得开发人员可以专注于开发服务的业务逻辑。

* 可以使用Spring Boot提供外部化配置等功能，使用Spring Cloud提供断路器等功能。**使用微服务基底的一个弊端是，开发者必须确保正在使用的编程语言/平台组合，有与之对应的微服务基底框架或类库**。

  <img src="https://4ever.web3img.com/2022/04/20/imagecc9abc6442dc8627.png" alt="imagecc9abc6442dc8627.png" border="0" align="left" width=250>



### 7）从微服务基底到服务网络

* 使用微服务基底模式的一个障碍是需要确保使用的编程语言有对应的微服务基底框架或类库，例如Java开发的Spring Boot和Spring Cloud对基于Node.js的服务无效。

* 为了避免此问题，引入服务网格。**服务网格把所有进出服务的网络流量通过一个网络层进行路由，这个网络层负责解决包括断路器、分布式追踪、服务发现、负载均衡和基于规则的流量路由等具有共性的问题。服务网格还可以通过在服务之间使用基于TLS的机制来保护进程间通信**。可使用的服务网格包括Linkerd、Istio、Conduit。

* 使用服务网格后，微服务基底承担的责任变少，只需要实现与应用程序代码紧密集成的问题，如外部化配置和健康检查。微服务基底必须通过传播分布式追踪消息来支持分布式追踪。

  <img src="https://4ever.web3img.com/2022/04/20/imagebc1ed233e5a27913.png" alt="imagebc1ed233e5a27913.png" border="0" align="left" width=450>



## （十二）部署微服务应用

> 部署包含两个相关联的概念：流程和结构。**部署流程包括一些由开发人员和运维人员执行的步骤，以便将软件投入到生产环境。部署架构定义了该软件运行的环境结构。**

<img src="https://4ever.web3img.com/2022/04/20/image79cbaa3fe1d7abbf.png" alt="image79cbaa3fe1d7abbf.png" border="0" align="left" width=500>



### 1）部署模式：编程语言特定的发布包格式

* 当需要部署应用程序的某个服务时，可选的一种方法是使用特定于编程语言的软件包部署服务。**使用此模式时，生产环境中部署的内容以及服务运行时管理的内容都是特定于语言的发布包中的服务。**对于基于Spring Boot的Java应用程序来说是可执行的JAR或WAR文件。首先要安装必要的运行时（如JDK），若是WAR文件还需要安装Web容器（如Tomcat）。**将程序发布包复制到计算机并启动该服务，每个服务实例都作为JVM进程运行。**

  <img src="https://4ever.web3img.com/2022/04/20/imagec475abe8c235a83d.png" alt="imagec475abe8c235a83d.png" border="0" align="left" width=450>

* 有时可以在计算机上部署单个服务实例，同时保留在同一台计算机部署多个服务实例的选项。有些语言还允许在单个进程中运行多个服务实例。

  <img src="https://4ever.web3img.com/2022/04/20/imageb503d34f03f318d7.png" alt="imageb503d34f03f318d7.png" border="0" align="left" width=450>

  <img src="https://4ever.web3img.com/2022/04/20/imageb3a37d1d270b692c.png" alt="imageb3a37d1d270b692c.png" border="0" align="left" width=450>

* **使用编程语言特定的发布包格式进行部署的好处**：
  * **快速部署**：**部署服务实例速度较快**，只需要将服务复制到主机并启动它。此外，**启动服务耗时很短**。
  * **高效的资源利用**：多个服务实例共享机器及其操作系统，若多个服务实例在同一进程中运行则效率更高。

* **使用编程语言特定的发布包格式进行部署的弊端**：
  * **缺乏对技术栈的封装**：运维团队必须了解部署每个服务的具体细节，包括特定版本的运行时、所需软件包的正确版本。尤其是服务用各种语言和框架编写时，开发团队必须与运维团队分享更多细节。
  * **无法约束服务实例消耗的资源**：一个进程可能会消耗机器的所有CPU或内存，争用其他服务实例和操作系统的资源。
  * **在同一台计算机上运行多个服务实例时缺少隔离**：缺乏隔离意味着行为不当的服务实例可能会影响其他服务实例。因此，应用程序存在不可靠的风险。
  * **很难自动判定防止服务实例的位置**：每台机器都有一组固定的资源、CPU、内存等。每个服务实例都需要一定的资源，以一种有效使用机器而不会使它们过载的方式将服务实例分配给机器非常重要。在本地部署服务时，通常需要手动确定放置位置。



### 2）部署模式：将服务部署为虚拟机

* **部署的另一种选择是将作为虚拟机镜像打包的服务部署到生产环境中，每个服务实例都是一个虚拟机**。虚拟机镜像由服务的部署流水线构建，**这个构建器创建包含服务代码和服务运行所需的任何软件的虚拟机镜像**。可选的构建虚拟机工具有很多，如Packer创建亚马逊机器镜像（AMI）。

  <img src="https://4ever.web3img.com/2022/04/20/image92cb79152b0bd0fc.png" alt="image92cb79152b0bd0fc.png" border="0" align="left" width=450>

* **将服务部署为虚拟机的好处**：
  * **虚拟机镜像封装了技术栈**：虚拟机镜像包含服务及其所有依赖项，它消除了错误来源，确保正确安装和设置服务运行所需的软件。封装了服务的技术栈，虚拟机镜像可以无需修改地部署在任何地方。用于部署服务的API成为虚拟机管理API，部署变得更加简单和可靠。
  * **隔离的服务实例**：每个服务实例都以完全隔离的方式运行，不会从其他服务窃取资源。
  * **使用成输的云计算基础设施**：当微服务部署为虚拟机时，可以利用成熟且高度自动化的云计算基础设施。AWS等公共云试图以避免机器过载的方式在物理机上调度虚拟机，还提供跨虚拟机的流量负载均衡和自动扩展等功能。

* **将服务部署为虚拟机的弊端**：
  * **资源利用效率较低**：每个服务实例拥有一整台虚拟机的开销，包括其操作系统。因此虚拟机可能未得到充分利用。
  * **部署速度相对较慢**：由于虚拟机的大小，构建虚拟机镜像也需要耗时较长。有许多内容要通过网络传输，且完整的虚拟机镜像需要通过网络传输。从镜像实例化虚拟机也是非常耗时的，在虚拟机内部运行的操作系统也需要一些时间来启动。
  * **系统管理的额外开销**：必须担负起给操作系统和运行时打补丁的责任。



### 3）部署模式：将服务部署为容器

* **容器是一种更轻量级的部署机制，是一种操作系统级的虚拟化机制**。从容器中运行的进程的角度来看，它就像在自己的机器上运行一样，有自己的IP地址，可以消除端口冲突。每个容器有自己的根文件系统，容器运行时使用操作系统机制将容器彼此隔离。

  <img src="https://4ever.web3img.com/2022/04/20/image2cf2dd5d376ac0a2.png" alt="image2cf2dd5d376ac0a2.png" border="0" align="left" width=250>

* **创建容器时，可以指定它的CPU和内存资源，以及依赖于容器实现的I/O资源等。容器在运行时会强制执行这些限制，并防止容器占用其机器资源**。尤其是使用Dockers编排框架（如Kubernetes）时，编排框架使用容器请求的资源来选择运行容器的底层机器。

  <img src="https://4ever.web3img.com/2022/04/20/imagebc48cc24464a09b8.png" alt="imagebc48cc24464a09b8.png" border="0" align="left" width=500>

* **容器镜像是由应用程序和运行服务所需的依赖软件组成的文件系统镜像，它通常是一个完整的Linux根文件系统**，也可以选择更轻量级的镜像。

* **使用Docker部署服务**：
  * **构建Docker镜像**：创建DockerFile，描述如何构建Docker容器镜像。包含指定了基础容器镜像、用于安全软件和配置容器的指令、创建容器时运行的脚本命令等。
  * **把Docker镜像推送到镜像仓库**：由于Docker镜像具有所谓的分层文件系统，使得Docker只需要通过网络传输部分镜像，即Docker只需要传输镜像仓库中不存在的那些层。
  * **运行Docker容器**：容器基础设施将镜像从仓库拉到生产服务器上，从该镜像创建一个或多个容器，每个容器就是一个服务实例。
* **将服务部署为容器的好处**：
  * 具有与将服务部署为虚拟机相同的好处，封装技术栈、服务实例隔离、服务实例资源受到限制。
  * 容器是轻量级技术，容器镜像构建较快，通过网络传输容器镜像也相对较快。容器启动也没有冗长的操作系统启动过程。
* **将服务部署为容器的弊端**：需要承担大量的容器镜像管理工作，必须负责给操作系统和运行时打补丁。必须管理容器基础设施以及容器运行可能需要的虚拟机基础设施。



### 4）使用Kubernetes部署应用程序

* K8S是一个Docker编排框架，它将一组计算机硬件资源转变为用于运行服务的单一资源池，是在生产环境中可靠运行容器化服务的选择。主要功能有三个：
  * **资源管理**：将一组计算机视为由CPU、内存和存储卷构成的资源池，将计算机集群视为一台计算机。
  * **调度**：选择要运行容器的机器，调度考虑容器的资源需求和每个节点的可用资源。还可以实现在同一节点上部署具有亲和性的容器，或保持特定的几个容器分散部署在不同的节点上（反亲和性）。
  * **服务管理**：实现命名和版本化服务的概念，这个概念可直接映射到微服务架构中的具体服务。编排框架确保始终运行所需数量的正常实例、实现请求的负载均衡、可执行服务的滚动升级（包括回滚）。

* **K8S的架构**：K8S集群中的计算机角色分为少量的主节点和大量的普通节点。**主节点负责管理集群，普通节点即工作节点会运行一个或多个Pod**。其中主节点运行的组件包含前4个，普通节点运行的组件包含后3个，如下所示。

  * **API服务器**：用于部署和管理服务的REST API，可被kubectl命令行使用。

  * **Etcd**：存储集群数据键值的NoSQL数据库。

  * **调度器**：选择要运行Pod的节点。

  * **控制器管理器**：运行控制器，确保集群状态和预期状态匹配。例如replication控制器通过启动和终止实例确保运行所需数量的服务实例。

  * **Kubelet**：创建和管理节点上运行的Pod。

  * **Kube-proxy**：管理网络，包括跨Pod的负载均衡。

  * **Pods**：应用程序服务。

    <img src="https://4ever.web3img.com/2022/04/20/image7b5f926605e43fb4.png" alt="image7b5f926605e43fb4.png" border="0" align="left" width=500>

* **使用K8S部署服务**：
  * **定义部署对象Deployment**：编写YAML文件，定义部署对象，指定运行Pod的副本数量、Docker镜像、容器的环境变量、K8S调用的健康检查接口。在此阶段可创建K8S Secret对象存放需要加密的环境变量。
  * **创建K8S服务**：由于Pod使用的动态IP地址，为了向服务发出HTTP请求，使用K8S内置的服务发现机制并定义K8S服务。K8S服务为Pod提供稳定的网络访问端点，具有IP地址和解析该IP地址的DNS名称，服务跨Pod对到该IP地址的流量进行负载均衡。

* **部署API Gateway**：K8S服务对象只能从集群内部访问，因此需要使用其他类型服务对象接收外部集群访问。
  * **NodePort服务对象**：可通过集群中所有节点上的集群范围的端口访问。任何集群节点到该端口的任何流量都会负载均衡到后端Pod。配置好NodePort服务对象后，可以配置AWS Elastic Load Balancer以跨节点对来自互联网的请求进行负载均衡。
  * **LoadBalancer服务对象**：自动配置特定于云的负载均衡器。

* **K8S更新正在运行的服务三步过程**：经过这三步后，K8S会将Pod进行滚动升级，逐步创建运行新版本Pod，并逐步终止运行旧版本Pod。它不会直接终止旧的Pod，而是直到替代品做好准备（使用readinessProbe健康检测机制）。若Pod启动失败可进行回滚。但Pod启动后失败造成的影响需要其他方式来解决。
  1. 构建新的容器镜像并推送至仓库，使用不同的版本标签进行标记。
  2. 编辑服务部署的YAML文件，以便引用新镜像。
  3. 使用kubectl命令更新部署。

* **使用服务网格分割部署与发布流程**：

  * **部署流程**：让服务开始在生产环境中运行。
  * **发布流程**：使最终用户可以访问服务。
  * **理想的服务部署到生产环境步骤**：
    1. 将新版本部署到生产环境，此时不向其路由任何最终用户请求。
    2. 在生产环境进行测试。
    3. 将其发布给少量最终用户。
    4. 逐步将其发布给越来越多用户，直到处理所有生产流量。
    5. 任何时候出现问题，都恢复旧版本。直到新版本正常工作，再删除旧版本。

  * **使用服务网格框架如Istio部署服务**：进行版本化部署、创建不同版本的路由规则、把测试流量路由到新版本、逐步把生产流量路由到新版本



### 5）部署模式：Server less部署

* 无论是特定于编程语言的发布包、服务作为虚拟机或容器，这几种部署模式都需要预先准备一些计算资源，即使它们处于闲置，也需要为它们付费。并且，必须管理系统，承担为操作系统和软件打补丁的工作，并包括机架和网络的管理、语言运行时的管理等。
* Serverless部署模式，是使用公共云提供的Serverless部署机制部署服务。例如将应用程序打包为ZIP文件或JAR文件，上传至AWS Lambda，并指定响应请求（也称事件）的函数的名称。AWS Lambda会自动运行充足的微服务实例来处理传入的请求，并根据所花费的事件和消耗的内存，为每个请求付费。开发者无需担心服务器、虚拟机或容器的任何方面。



## （十三）微服务架构的重构策略

### 1）重构到微服务需要考虑的问题

* **为什么要重构单体应用**：
  * **交付缓慢**：应用程序难以理解、维护和测试，开发人员工作效率低下。
  * **充满故障的软件交付**：缺乏可测试性意味着软件会经常出错。
  * **可扩展性差**：扩展单体应用程序困难，它将具有完全不同资源需求的模块组合在一个可执行组件肿。缺乏可扩展性将应用程序扩展到特定规模以上是不可能或昂贵的。

* **绞杀单体应用**：应该逐步重构单体应用程序，而不是直接推倒重来。逐步构建一个新的、被称为绞杀者应用程序的应用。

  <img src="https://4ever.web3img.com/2022/04/20/image1acf7ad62fdf4c91.png" alt="image1acf7ad62fdf4c91.png" border="0" align="left" width=450>

* **尽早并且频繁地体现出价值**：逐步重构微服务架构的一个重要好处是可以立即获得回报。可以先将应用程序的高价值部分迁移到微服务架构。更早的交付意味着有助于获得业务团队对重构工作的支持。
* **尽可能少对单体做出修改**：在迁移到微服务架构时，应避免对单体进行大范围的修改。
* **部署基础设施为时尚早**：当只有少量业务或者不需要复杂的部署方式和具备可观测性的运行时基础设施。在重构时只需要进行少量在此方面的投资。



### 2）将单体应用程序重构为微服务架构的若干策略

* **将新功能实现为服务**：降低单体的生长速度，加速新功能的开发，快速展示采用微服务架构的价值。

  * **把新的服务与单体集成**：

    <img src="https://4ever.web3img.com/2022/04/20/image531c20519dbbb8d1.png" alt="image531c20519dbbb8d1.png" border="0" align="left" width=450>

  * **何时把新功能实现为服务**：若某个功能太小以致于无法称为有意义的服务，则解决方案通常是在单体实现新功能，再将该功能和其他相关功能提取到服务肿。

* **隔离表现层与后端**：表现逻辑层与业务和数据访问逻辑层之间通常存在清晰的边界，业务层具有粗粒度API，由一个或多个封装业务逻辑的门面Facade组成。这个API是一个自然的接缝，可以沿着它将单体分为两个较小的应用程序。

  <img src="https://4ever.web3img.com/2022/04/20/image85ab550bc8bd8e5c.png" alt="image85ab550bc8bd8e5c.png" border="0" align="left" width=450>

* **提取业务能力到服务中**：想要提取到服务中的功能是对单体应用自上而下的一个垂直切片，包含实现API端点的入站适配器、领域逻辑、出站适配器（如数据库访问逻辑）、单体的数据库模式。

  <img src="https://pic.dogimg.com/2022/04/21/6260cbc74ac83.png" alt="1650510769703.png" title="1650510769703.png" align="left" width=500/>

  * **拆解领域模型**：首先遇到的挑战是**消除跨越服务边界的对象引用，解决方法之一是使用DDD思想，聚合使用主键而不是对象引用**。缺点是期望对象引用的类的客户端会产生很大影响。

  * **重构数据库**：从单体中提取服务时，也会移动数据。拆分实体时，需要拆分相应的数据库表并将新表移动到服务中。一种有效技术是**复制数据，以便允许逐步更新数据库的客户端以使用新模式**。

  * **复制数据以避免广泛修改**：从单体中提取服务时，也可以将单体中的实体在过渡期保持不变，将数据从服务复制回单体来保持更新。只需要在单体的代码中找到更新这些字段的位置，改为调用服务即可。

    <img src="https://pic.dogimg.com/2022/04/21/6260cf04835dc.png" alt="1650511598440.png" title="1650511598440.png" align="left" width=500/>

  * **确定提取何种服务**：
    * **加速开发**：如果应用程序的路线图表明应用程序的特定部分将在不久进行大量开发，则将其转换为服务可加速开发。
    * **解决性能、可扩展性或可靠性问题**：如果应用程序的特定部分存在性能、可扩展性问题或不可靠，那么将其转换为服务是有价值的。
    * **允许提取其他一些服务**：由于模块之间的依赖关系，有时提取一个服务会简化另一个服务的提取。



### 3）设计服务与单体的协作方式

* **设计集成胶水**：服务和单体之间的交互由集成胶水代码来实现。它们使用某种进程间通信机制。
  * **设计集成胶水的API**：由于服务的业务逻辑不需要知道集成胶水用于检索信息的进程间通信机制，因此该机制应该用接口封装。同理，单体调用服务操作也需要定义服务接口。
  * **选择交互方式和进程间通信机制**：若一边需要查询另一方拥有的数据，一种选择是实现查询API，另一种选择是保留数据副本，实现CQRS。
  * **实现反复层**：是一个软件层，用于在两个不同的领域模型之间进行转换，防止一个模型的概念污染另一个模型。
  * **单体如何发布和订阅领域事件**：一种方式是使用与服务相同的领域事件发布机制，需要在代码中找到更改特定实体的位置，插入对事件发布API的调用。另一种方法是在数据库级别发布领域事件，使用事务逻辑拖尾或轮询。前者修改麻烦，后者无法发布高级业务事件。

* **在服务和单体之间维持数据一致性**：单体有可能无法支持Saga，例如需要补偿事务来撤销更改。
  * **修改单体应用使其支持补偿事务的挑战**：例如使用类似语义锁的补偿事务调整，可能造成需要大范围修改单体应用。
  * **Saga并不总是要求单体支持补偿事务**：只有在单体事务之后的事务可能会失败才需要支持补偿事务，若单体事务是一个关键性事务或可重复性事务，则单体不需要执行补偿性事务。因此，只需要对单体进行最小的更改即可支持Saga。
  * **选择合适的服务提取顺序，避免在单体中实现补偿事务**：通过仔细对要提取服务进行排序，可以避免必须对单体进行大范围的修改以支持可补偿事务。确保单体事务是关键性事务或可重复性事务。

* **处理身份验证和访问授权**：基于微服务的应用程序使用如JWT的令牌来传递用户身份，而单体应用程序使用内存中会话状态来传递用户身份。对了使它们兼容，可以对单体的登录请求处理程序进行修改，返回一个额外的cookie，包含用户信息。

  <img src="https://pic.dogimg.com/2022/04/21/6260d698177d5.png" alt="1650513538695.png" title="1650513538695.png" align="left" width=500/>
